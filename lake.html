
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pixel Bird - 功德无量版</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; touch-action: none; user-select: none; box-sizing: border-box; }
        body { 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; margin: 0; 
background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);  
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            overflow: hidden; font-family: system-ui, sans-serif;
        }
        @keyframes gradientBG { 0% {background-position: 0% 50%} 50% {background-position: 100% 50%} 100% {background-position: 0% 50%} }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 500px; max-height: 900px; display: flex; justify-content: center; align-items: center; }
        canvas { border: 4px solid rgba(255,255,255,0.8); border-radius: 20px; background: rgba(0,0,0,0.2); backdrop-filter: blur(5px); width: 95%; height: auto; aspect-ratio: 2 / 3; image-rendering: pixelated; }
        .info { position: absolute; top: 40px; color: #fff; text-align: center; width: 100%; pointer-events: none; }
        #hiScore { font-size: 24px; font-weight: 900; text-shadow: 0 0 10px #fff; }
        #next-hint { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 10px; border: 2px solid #fff; }
        #next-color-box { width: 30px; height: 30px; border-radius: 5px; }
        #power-ui { position: absolute; bottom: 12%; width: 60%; height: 12px; background: rgba(0,0,0,0.6); border-radius: 6px; border: 2px solid #fff; overflow: hidden; display: none; }
        #power-bar { width: 100%; height: 100%; }
        .tips { position: absolute; bottom: 20px; color: rgba(255,255,255,0.5); font-size: 12px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="info"><div id="hiScore">HI: 0</div></div>
        <div id="next-hint"><div id="next-color-box"></div></div>
        <div id="power-ui"><div id="power-bar"></div></div>
        <canvas id="birdCanvas"></canvas>
        <div class="tips">左侧:跳跃 | 右侧:变色/敲木鱼</div>
    </div>

<script>
window.onload = function() {
    const canvas = document.getElementById('birdCanvas');
    const ctx = canvas.getContext('2d');
    const hiScoreEl = document.getElementById('hiScore');
    const nextBox = document.getElementById('next-color-box');
    const powerUI = document.getElementById('power-ui');
    const powerBar = document.getElementById('power-bar');

    const LOGICAL_WIDTH = 320, LOGICAL_HEIGHT = 480;
    const COLOR_PALETTE = ['#FF3333', '#FFAC33', '#FFEA33', '#33FF57', '#33DBFF', '#B533FF'];
    
    let birdColorIndex = 2, birdY, birdX, velocity, score, pipes, frame, gameOver;
    let combo = 0, lastPipeColor = '', scoreScale = 1;
    let powerItems = [], particles = [], floatTexts = [];
    
    // 道具计时器
    let invincTimer = 0, sprintTimer = 0, rhythmTimer = 0, muyuTimer = 0;
    const DURATION = 300;
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(freq, type, duration, vol=0.08) {
        try {
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        } catch(e) {}
    }

    function createParticles(x, y, color, count=10) {
        for(let i=0; i<count; i++) {
            particles.push({
                x, y, color,
                vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                life: 1.0, size: Math.random()*3+1
            });
        }
    }

    function reset() {
        birdY = 240; birdX = 50; velocity = 0; score = 0; combo = 0; 
        pipes = []; frame = 0; gameOver = false; powerItems = []; particles = []; floatTexts = [];
        invincTimer = 0; sprintTimer = 0; rhythmTimer = 0; muyuTimer = 0;
        powerUI.style.display = 'none';
        hiScoreEl.innerText = "HI: " + (localStorage.getItem('pixelBirdHighScore') || 0);
        updateNextHint(); createPipe();
    }

    function updateNextHint() { 
        nextBox.style.backgroundColor = COLOR_PALETTE[(birdColorIndex + 1) % COLOR_PALETTE.length]; 
    }

    function createPipe() {
        const gap = 135; const h = Math.floor(Math.random() * (LOGICAL_HEIGHT - 280)) + 60;
        const pColor = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];
        pipes.push({ x: LOGICAL_WIDTH, y: h, gap, passed: false, color: pColor });

        const rand = Math.random();
        const itemY = h + gap/2;
        if (rand < 0.05) powerItems.push({ x: LOGICAL_WIDTH + 20, y: itemY, type: 'muyu' }); // 木鱼
        else if (rand < 0.09) powerItems.push({ x: LOGICAL_WIDTH + 20, y: itemY, type: 'star' });
        else if (rand < 0.13) powerItems.push({ x: LOGICAL_WIDTH + 20, y: itemY, type: 'bolt' });
        else if (rand < 0.17) powerItems.push({ x: LOGICAL_WIDTH + 20, y: itemY, type: 'bomb' });
    }

    function handleAction(isRightSide) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (gameOver) { reset(); draw(); return; }

        if (isRightSide) {
            // 变色逻辑
            birdColorIndex = (birdColorIndex + 1) % COLOR_PALETTE.length;
            updateNextHint();
            
            // 木鱼特殊逻辑：敲击清场
            if (muyuTimer > 0) {
                playSound(800, 'sine', 0.1, 0.4); // 模拟木鱼敲击声
                score += 2; 
                floatTexts.push({x: birdX, y: birdY, text: "功德+2", life: 40, color: "#ffd700"});
                createParticles(birdX+40, birdY+12, "#ffd700", 5);
                // 震碎最近的一根管子
                for(let p of pipes) {
                    if(!p.passed && p.x > birdX) {
                        p.x = -100; p.passed = true;
                        break;
                    }
                }
            } else {
                playSound(600, 'triangle', 0.05);
            }
        } else {
            // 跳跃逻辑
            if (sprintTimer === 0) {
                velocity = -3.5;
                playSound(300, 'sine', 0.1);
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
        let step = 1.0; if (sprintTimer > 0) step = 3.5;

        // 道具 UI 逻辑
        const activeTimer = Math.max(invincTimer, sprintTimer, rhythmTimer, muyuTimer);
        if (activeTimer > 0) {
            powerUI.style.display = 'block';
            powerBar.style.width = (activeTimer / DURATION * 100) + '%';
            if (sprintTimer > 0) { sprintTimer--; powerBar.style.background = "#fff"; }
            else if (invincTimer > 0) { invincTimer--; powerBar.style.background = "#ff0"; }
            else if (muyuTimer > 0) { muyuTimer--; powerBar.style.background = "#ffd700"; }
            else if (rhythmTimer > 0) { rhythmTimer--; powerBar.style.background = "#B533FF"; }
        } else { powerUI.style.display = 'none'; }

        // 绘制道具
        powerItems.forEach((item, i) => {
            item.x -= 1.4 * step;
            ctx.save(); ctx.translate(item.x, item.y); ctx.rotate(frame * 0.05);
            if(item.type === 'muyu') {
                ctx.fillStyle="#8d6e63"; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
                ctx.fillStyle="#5d4037"; ctx.fillRect(-7, 2, 14, 3); // 木鱼缝隙
                ctx.fillStyle="#fff"; ctx.globalAlpha=0.4; ctx.beginPath(); ctx.arc(-3,-3,3,0,Math.PI*2); ctx.fill();
            } else if(item.type === 'star') { ctx.fillStyle="#ff0"; ctx.beginPath(); for(let j=0;j<5;j++){ctx.lineTo(Math.cos((18+j*72)/180*Math.PI)*10,-Math.sin((18+j*72)/180*Math.PI)*10);ctx.lineTo(Math.cos((54+j*72)/180*Math.PI)*5,-Math.sin((54+j*72)/180*Math.PI)*5);} ctx.fill(); }
            else if(item.type === 'bolt') { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.moveTo(-5,-10); ctx.lineTo(5,-2); ctx.lineTo(0,0); ctx.lineTo(8,10); ctx.lineTo(-2,2); ctx.fill(); }
            else if(item.type === 'bomb') { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill(); }
            ctx.restore();

            if (Math.hypot(birdX + 16 - item.x, birdY + 12 - item.y) < 25) {
                if(item.type === 'muyu') { muyuTimer = DURATION; playSound(150, 'sine', 0.2, 0.5); }
                else if(item.type === 'star') invincTimer = DURATION;
                else if(item.type === 'bolt') sprintTimer = 150;
                else if(item.type === 'bomb') { pipes.forEach(p => { if(!p.passed) { p.x = -100; p.passed = true; score++; }}); }
                powerItems.splice(i, 1);
                createParticles(item.x, item.y, "#fff");
            }
        });

        // 绘制粒子与文字
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.02; ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            if(p.life <= 0) particles.splice(i, 1);
        });
        floatTexts.forEach((ft, i) => {
            ft.y -= 1; ft.life--; ctx.globalAlpha = ft.life/40; ctx.fillStyle = ft.color;
            ctx.font = "bold 16px Arial"; ctx.fillText(ft.text, ft.x - 20, ft.y);
            if(ft.life <= 0) floatTexts.splice(i, 1);
        });
        ctx.globalAlpha = 1.0;

        // 小鸟绘制
        ctx.save(); ctx.translate(birdX + 16, birdY + 12);
        if (sprintTimer > 0) ctx.scale(1.5, 0.8); else ctx.rotate(velocity * 0.08);
        ctx.fillStyle = (invincTimer > 0 || sprintTimer > 0) ? `hsl(${frame*10%360}, 70%, 60%)` : COLOR_PALETTE[birdColorIndex];
        if(muyuTimer > 0) { ctx.shadowBlur = 20; ctx.shadowColor = "#ffd700"; }
        ctx.fillRect(-16, -12, 32, 24); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(-16, -12, 32, 24);
        ctx.restore();

        // 游戏运行逻辑
        if (!gameOver) {
            if (sprintTimer > 0) { birdY += (240 - birdY) * 0.1; } else { velocity += 0.18; birdY += velocity; }
            frame++; if (frame % 110 === 0) createPipe();
        }

        // 水管渲染
        pipes.forEach((p, i) => {
            p.x -= 1.4 * step;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, 0, 50, p.y); ctx.fillRect(p.x, p.y + p.gap, 50, LOGICAL_HEIGHT);

            let hit = (birdX + 26 > p.x && birdX < p.x + 46 && (birdY < p.y || birdY + 22 > p.y + p.gap || (COLOR_PALETTE[birdColorIndex] !== p.color && invincTimer <= 0 && sprintTimer <= 0)));
            if (hit) {
                if (sprintTimer > 0 || invincTimer > 0) { p.x = -100; p.passed = true; score++; }
                else { gameOver = true; playSound(100, 'square', 0.3); }
            }
            if (!p.passed && p.x + 50 < birdX) {
                p.passed = true; combo = (p.color === lastPipeColor) ? combo + 1 : 1;
                lastPipeColor = p.color; score += combo; scoreScale = 1.3;
                if(score > (localStorage.getItem('pixelBirdHighScore') || 0)) localStorage.setItem('pixelBirdHighScore', score);
            }
            if (p.x < -60) pipes.splice(i, 1);
        });

        if (birdY > LOGICAL_HEIGHT || birdY < 0) gameOver = true;

        // 分数渲染
        ctx.save(); ctx.translate(LOGICAL_WIDTH/2, 80); ctx.scale(scoreScale, scoreScale);
        ctx.fillStyle = "#fff"; ctx.font = "bold 40px Arial"; ctx.textAlign = "center";
        ctx.fillText(score, 0, 0); ctx.restore(); if(scoreScale > 1) scoreScale -= 0.02;

        if (gameOver) {
            ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(0,0,LOGICAL_WIDTH, LOGICAL_HEIGHT);
            ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.font = "20px Arial";
            ctx.fillText("游戏结束 - 点击重开", LOGICAL_WIDTH/2, 240);
        } else {
            requestAnimationFrame(draw);
        }
    }

    // 输入绑定
    const handleInput = (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const x = (clientX - rect.left) * (LOGICAL_WIDTH / rect.width);
        handleAction(x > LOGICAL_WIDTH / 2);
    };

    canvas.addEventListener('touchstart', handleInput, {passive: false});
    canvas.addEventListener('mousedown', handleInput);
    window.addEventListener('keydown', (e) => {
        if(e.code==='Space') handleAction(false);
        if(e.code==='KeyC') handleAction(true);
    });

    function resize() { canvas.width = LOGICAL_WIDTH; canvas.height = LOGICAL_HEIGHT; }
    window.addEventListener('resize', resize); resize(); reset(); draw();
};
</script>
</body>
</html>
