
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal CLI (全功能)</title>
    <style>
         @keyframes rainbow-color-change {
            0%, 100% { color: #ff0000; } /* Red */
            14% { color: #ff8b00; } /* Orange */
            28% { color: #e8ff00; } /* Yellow */
            42% { color: #5dff00; } /* Green */
            56% { color: #00b9ff; } /* Blue */
            70% { color: #5d00ff; } /* Indigo */
            84% { color: #e800ff; } /* Violet */
        }
        /* CSS Reset and Global Styles */
        * {
            box-sizing: border-box;
        }
        :root {
            --terminal-bg: #000000;
            --terminal-text: #00ff00; /* Bright Green */
            --prompt-color: #00ffff; /* Cyan for the prompt text */
            --dir-color: #33ccff; /* Blue for directories */
            --file-color: #ffffff; /* White for files */
            --terminal-width-desktop: 800px;
            --terminal-height-desktop: 600px;
            --font-size-desktop: 1rem;
            --font-size-mobile: 0.9rem;
        }
        body {
            background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            font-family: Comic Sans MS, cursive, sans-serif;
            color: var(--terminal-text);
            font-size: var(--font-size-desktop);
            animation: rainbow-color-change 3s linear infinite alternate;
        }
        /* --- 终端容器 --- */
        #terminal-container {
            background-color: var(--terminal-bg);
            width: 100%;
            max-width: var(--terminal-width-desktop);
            height: 100vh; /* Mobile height */
            max-height: var(--terminal-height-desktop); /* Desktop height limit */
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;         
        }
        /* --- 输出区域 --- */
        #output {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            line-height: 1.4;
            white-space: pre-wrap; 
            word-break: break-all;
        }
        /* Custom Scrollbar for better retro look */
        #output::-webkit-scrollbar {
            width: 8px;
        }
        #output::-webkit-scrollbar-track {
            background: #222;
        }
        #output::-webkit-scrollbar-thumb {
            background: #004d00;
            border-radius: 4px;
        }
        #output::-webkit-scrollbar-thumb:hover {
            background: var(--terminal-text);
        }                        
        /* --- 输入行 --- */
        #input-line {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-top: 1px solid #004d00;
            flex-shrink: 0;         
        }
        #prompt {
            color: var(--prompt-color);
            margin-right: 8px;
            flex-shrink: 0;
            transition: color 0.3s;
        }
        #commandInput {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--terminal-text);
            font-family: inherit;
            font-size: inherit;
            outline: none;
            caret-color: var(--terminal-text); 
            padding: 0;
            margin: 0;
        }                        
        /* --- 输出行样式 --- */
        .output-line {
            margin: 0;
        }
        .output-line span {
            color: var(--prompt-color);         
        }
        .error {
            color: #ff4500; /* OrangeRed for errors */
        }
        .welcome {
            color: #ffff00; /* Yellow for welcome text */
            margin-bottom: 10px;
        }
        .dir {
            color: var(--dir-color);
            font-weight: bold;
        }                        
        .file {
            color: var(--file-color);
        }
        /* 专门用于 display 命令的图像样式 */
        .output-line img {
            max-width: 100%; 
            height: auto; 
            margin-top: 10px; 
            border: 1px solid #00ff00; 
            display: block; /* 确保图片独占一行 */
        }                
        /* --- 移动端优化 --- */
        @media (max-width: 768px) {
            body {
                font-size: var(--font-size-mobile);
                padding: 0;
            }
            #terminal-container {
                border-radius: 0;
                height: 100vh; 
            }
            #output {
                padding: 10px;
            }
            #input-line {
                padding: 8px 10px;
            }
        }
    </style>
</head>
<body>
    <div id="terminal-container">
        <div id="output">
        </div>
        <div id="input-line">
            <span id="prompt">user@web-cli:~$</span>
            <input type="text" id="commandInput" autofocus>
        </div>
    </div>
    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('commandInput');
        const promptSpan = document.getElementById('prompt');
        const initialPromptText = "user@web-cli:";
        const CLI_USER = 'web-cli-user';
                        
        let history = [];
        let historyIndex = -1;
        let currentPath = '/home/user'; // 当前工作目录
        let gkrellmIntervalId = null; // 用于存储 gkrellm 的定时器ID
        let gifwrapIntervalId = null; // 用于存储 gifwrap 的定时器ID
                        
        // --- 全局数据 ---        
        // 箴言列表                
        const fortunes = [
            "知者不言，言者不知。",
            "人生就像一盒巧克力，你永远不知道下一块会是什么味道。",
            "重要的不是你站的位置，而是你朝向的方向。",
            "我们最大的荣耀不在于永不跌倒，而在于每次跌倒后都能站起来。",
            "衡量一个人幸福与否的标准，不是他拥有什么，而是他对失去的恐惧程度。",
            "自然是一座神殿，那里活的支柱 / 有时吐出混乱的语言； / 人行走在符号的森林中， / 符号用熟悉的目光观察他。如悠长迴响彼此交织的 / 遥远声音， / 颜色、声音、气味相互呼应。",
            "一切都在改变，没有事物消亡。",
            "梦想是注定孤独的旅行，路上少不了质疑和嘲笑。",
            "工资就像方便面，加量不加价。"
        ];
        // 模拟文件系统结构
        const fileSystem = {
            name: '/',
            type: 'dir',
            contents: {
                'home': {
                    name: 'home', type: 'dir', contents: {
                        'user': {
                            name: 'user', type: 'dir', contents: {
                                'Documents': { name: 'Documents', type: 'dir', contents: {} },
                                'Images': { name: 'Images', type: 'dir', contents: {} },
                                'music.mp3': { name: 'music.mp3', type: 'file' },
                                'README.txt': { name: 'README.txt', type: 'file' }
                            }
                        }
                    }
                },
                'etc': { name: 'etc', type: 'dir', contents: { 'hosts': { name: 'hosts', type: 'file' } } },
                'bin': { name: 'bin', type: 'dir', contents: {} }
            }
        };
                
        // --- FS 工具函数 ---        
        function getDirNode(path) {
            let parts = path.split('/').filter(p => p.length > 0);
            let currentNode = fileSystem;                        
            
            for (const part of parts) {
                if (currentNode.contents && currentNode.contents[part]) {
                    currentNode = currentNode.contents[part];
                } else {
                    return null;                                 
                }
            }
            return currentNode;
        }

        // 解析输入路径并返回父节点和目标名称
        function resolvePath(inputPath, currentDir) {
            let absolutePath;
            let parentPath;
            let targetName;

            if (inputPath.startsWith('/')) {
                absolutePath = inputPath.replace(/\/$/, '');
                parentPath = absolutePath.substring(0, absolutePath.lastIndexOf('/'));
                if (parentPath === '') parentPath = '/';
                targetName = absolutePath.substring(absolutePath.lastIndexOf('/') + 1);
            } else {
                absolutePath = currentDir === '/' ? `/${inputPath}` : `${currentDir}/${inputPath}`;
                parentPath = currentDir;
                targetName = inputPath.split('/').pop();
            }
            
            return {
                absolutePath: absolutePath,
                parentPath: parentPath,
                targetName: targetName,
                parentNode: getDirNode(parentPath)
            };
        }

        function getCurrentDirNode() {
            return getDirNode(currentPath);
        }

        function updatePrompt() {
            promptSpan.innerText = `${initialPromptText}${currentPath}~$`;
        }                
        
        // 写入新的输出行 (纯文本)        
        function writeOutput(text, className = 'output-text') {
            const lines = text.split('\n');
            lines.forEach(line => {
                const p = document.createElement('p');
                p.className = `output-line ${className}`;
                p.textContent = line;
                output.appendChild(p);
            });
            scrollToBottom();
        }                

        // 写入带 HTML 的输出行 (用于 display 命令)        
        function writeHtmlOutput(htmlContent) {
            const p = document.createElement('p');
            p.className = 'output-line';
            p.innerHTML = htmlContent;
            output.appendChild(p);
            scrollToBottom();
        }

        // 写入带提示符的命令历史        
        function writeCommandHistory(commandLine) {
            const p = document.createElement('p');
            p.className = 'output-line';
            p.innerHTML = `<span style="color:var(--prompt-color);">${promptSpan.innerText}</span> ${commandLine}`;
            output.appendChild(p);
        }

        // 自动滚动到底部        
        function scrollToBottom() {
            output.scrollTop = output.scrollHeight;
        }
        
        // --- Tab 自动补全逻辑 ---
        function autoComplete() {
            const fullInput = input.value;
            const parts = fullInput.trim().split(/\s+/);
            const lastPart = parts.pop();
            const prefix = parts.join(' ') + (parts.length > 0 ? ' ' : '');

            // 1. 补全命令本身
            if (parts.length === 0 || (parts.length === 1 && fullInput.endsWith(parts[0]))) {
                const matchingCommands = Object.keys(commands).filter(cmd => cmd.startsWith(fullInput.trim()));

                if (matchingCommands.length === 1) {
                    input.value = matchingCommands[0] + ' ';
                } else if (matchingCommands.length > 1) {
                    writeCommandHistory(fullInput);
                    writeOutput(matchingCommands.join('\t'));
                }
                return;
            }

            // 2. 补全文件/目录 (仅支持当前目录内的相对路径)
            if (lastPart.includes('/') && !lastPart.startsWith('/')) {
                // 暂不支持复杂的相对路径补全，仅处理当前目录下的补全
                return;
            }

            let searchDir = getCurrentDirNode();
            let searchPrefix = lastPart;
            
            // 处理绝对路径补全
            if (lastPart.startsWith('/')) {
                const { parentPath, targetName } = resolvePath(lastPart, currentPath);
                searchDir = getDirNode(parentPath);
                searchPrefix = targetName;
            }

            if (!searchDir || !searchDir.contents) {
                return; // 无法补全
            }

            const candidates = Object.keys(searchDir.contents).filter(name => name.startsWith(searchPrefix));
            
            if (candidates.length === 1) {
                const targetName = candidates[0];
                const targetNode = searchDir.contents[targetName];
                let suffix = targetNode.type === 'dir' ? '/' : ' ';
                
                // 构建新的输入值
                let newValue;
                if (lastPart.startsWith('/')) {
                    // 绝对路径补全：替换路径的最后一个部分
                    newValue = prefix + lastPart.substring(0, lastPart.lastIndexOf('/') + 1) + targetName + suffix;
                } else {
                    // 相对路径补全：替换当前输入的最后一个词
                    newValue = prefix + targetName + suffix;
                }
                input.value = newValue;

            } else if (candidates.length > 1) {
                writeCommandHistory(fullInput);

                // 尝试找到最长公共前缀
                let commonPrefix = candidates.reduce((prev, curr) => {
                    let i = 0;
                    while (i < prev.length && i < curr.length && prev[i] === curr[i]) {
                        i++;
                    }
                    return prev.substring(0, i);
                });

                if (commonPrefix.length > searchPrefix.length) {
                    // 补全到最长公共前缀
                    input.value = prefix + commonPrefix;
                } else {
                    // 显示所有匹配项
                    const displayList = candidates.map(name => {
                        return searchDir.contents[name].type === 'dir' ? `<span class="dir">${name}/</span>` : name;
                    }).join('&nbsp;&nbsp;&nbsp;');
                    writeHtmlOutput(displayList);
                }
            }
        }


        // --- 核心命令执行 ---                        
        const commands = {
            'help': {
                description: '显示可用命令列表。',
                execute: () => {
                    let helpOutput = '可用命令 (总计 ' + Object.keys(commands).length + ' 个):\n';
                    for (const cmd in commands) {
                        helpOutput += `  ${cmd.padEnd(12)} - ${commands[cmd].description}\n`;
                    }
                    writeOutput(helpOutput);
                }
            },
            'clear': {
                description: '清空终端屏幕。',
                execute: () => {
                    output.innerHTML = '';
                    writeWelcome();
                }
            },
            'echo': {
                description: '在终端上打印文本。用法: echo <文本>',
                execute: (args) => {
                    writeOutput(args.join(' '));
                }
            },
            'date': {
                description: '显示当前日期和时间。',
                execute: () => {
                    writeOutput(new Date().toLocaleString());
                }
            },
            'whoami': {
                description: '显示当前用户名。',
                execute: () => {
                    writeOutput(CLI_USER);
                }
            },
            'who': {
                description: '显示当前登录的用户。',
                execute: () => {
                    const date = new Date().toLocaleDateString('zh-CN', {month: 'numeric', day: 'numeric'});
                    const time = new Date().toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
                    writeOutput(`${CLI_USER.padEnd(10)} pts/0        ${date} ${time}`);
                }
            },
            'pwd': {
                description: '打印当前工作目录。',
                execute: () => {
                    writeOutput(currentPath);
                }
            },
            'ls': {
                description: '列出当前目录内容。',
                execute: () => {
                    const node = getCurrentDirNode();
                    if (!node || node.type !== 'dir') {
                        writeOutput(`错误: 无法读取目录 ${currentPath}`, 'error');
                        return;
                    }                                                            
                    const items = Object.values(node.contents).sort((a, b) => {
                        if (a.type === 'dir' && b.type === 'file') return -1;
                        if (a.type === 'file' && b.type === 'dir') return 1;
                        return a.name.localeCompare(b.name);
                    });

                    items.forEach(item => {
                        const typeClass = item.type === 'dir' ? 'dir' : 'file';
                        const name = item.type === 'dir' ? item.name + '/' : item.name;
                                                                        
                        const span = document.createElement('span');
                        span.className = `output-item ${typeClass}`;
                        span.textContent = name;

                        output.appendChild(span);
                        output.innerHTML += '&nbsp;&nbsp;&nbsp;'; 
                    });
                                                            
                    output.appendChild(document.createElement('br'));
                    scrollToBottom();
                }
            },
            'cd': {
                description: '切换目录。用法: cd <目录名>',
                execute: (args) => {
                    const target = args[0];
                    if (!target) {
                        currentPath = '/home/user';
                        updatePrompt();
                        return;
                    }
                    
                    let newPath;
                    if (target === '/') {
                        newPath = '/';
                    } else if (target.startsWith('/')) {
                        newPath = target;
                    } else if (target === '..') {
                        if (currentPath === '/') return;
                        newPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                        if (newPath === '') newPath = '/'; 
                    } else {
                        // 相对路径
                        newPath = currentPath === '/' ? `/${target}` : `${currentPath}/${target}`;
                    }

                    // 清理路径中的连续斜杠
                    newPath = newPath.replace(/\/\/+/g, '/');

                    const node = getDirNode(newPath);

                    if (!node) {
                        writeOutput(`cd: 目录不存在: ${target}`, 'error');
                    } else if (node.type !== 'dir') {
                        writeOutput(`cd: 不是目录: ${target}`, 'error');
                    } else {
                        currentPath = newPath.endsWith('/') && newPath.length > 1 ? newPath.slice(0, -1) : newPath;
                        updatePrompt();
                    }
                }
            },
            'touch': {
                description: '在当前目录创建一个空文件。用法: touch <文件名>',
                execute: (args) => {
                    if (args.length === 0) {
                        writeOutput('touch: 缺少文件操作数。', 'error');
                        return;
                    }
                    const filename = args[0];
                    const currentNode = getCurrentDirNode();
                    if (!currentNode || currentNode.type !== 'dir') {
                        writeOutput(`touch: 无法创建文件: ${currentPath} 不是一个有效目录。`, 'error');
                        return;
                    }
                    if (currentNode.contents[filename]) {
                        writeOutput(`touch: 文件已存在: ${filename}`, 'error');
                        return;
                    }
                    currentNode.contents[filename] = { 
                          name: filename, 
                          type: 'file', 
                          created: new Date().toISOString() 
                    };
                    writeOutput(`文件 ${filename} 已创建。`);
                }
            },
            'mkdir': {
                description: '创建一个新目录。用法: mkdir <目录名>',
                execute: (args) => {
                    if (args.length === 0) {
                        writeOutput('mkdir: 缺少目录名。', 'error');
                        writeOutput('用法: mkdir <目录名>', 'error');
                        return;
                    }
                    const dirname = args[0];
                    const currentNode = getCurrentDirNode();
                    if (dirname.includes('/') || dirname.includes('\\')) {
                        writeOutput(`mkdir: 目录名不能包含路径分隔符: ${dirname}`, 'error');
                        return;
                    }                                                            
                    if (!currentNode || currentNode.type !== 'dir') {
                        writeOutput(`mkdir: 内部错误，当前路径无效。`, 'error');
                        return;
                    }
                    if (currentNode.contents[dirname]) {
                        writeOutput(`mkdir: 文件或目录已存在: ${dirname}`, 'error');
                        return;
                    }
                    currentNode.contents[dirname] = { 
                          name: dirname, 
                          type: 'dir', 
                          contents: {}
                    };
                    writeOutput(`目录 ${dirname} 已创建。`);
                }
            },
            'rmdir': {
                description: '删除空目录。用法: rmdir <目录名>',
                execute: (args) => {
                    if (args.length === 0) {
                        writeOutput('rmdir: 缺少操作数。', 'error');
                        writeOutput('用法: rmdir <目录名>', 'error');
                        return;
                    }
                    const target = args[0];                    
                    
                    const { parentPath, targetName, targetAbsolutePath, parentNode } = resolvePath(target, currentPath);

                    if (targetAbsolutePath === '/') {
                        writeOutput('rmdir: 无法删除根目录 "/"。', 'error');
                        return;
                    }

                    const targetNode = getDirNode(targetAbsolutePath);
                    
                    if (!targetNode) {
                        writeOutput(`rmdir: 目录不存在: ${target}`, 'error');
                        return;
                    }
                    if (targetNode.type !== 'dir') {
                        writeOutput(`rmdir: 不是目录: ${target}`, 'error');
                        return;
                    }                                                            
                    if (Object.keys(targetNode.contents).length > 0) {
                        writeOutput(`rmdir: 目录非空: ${target}`, 'error');
                        return;
                    }                                                            
                    if (parentNode && parentNode.contents && parentNode.contents[targetName]) {
                        delete parentNode.contents[targetName];
                        writeOutput(`目录 ${targetName} 已删除。`);
                    } else {
                        writeOutput(`rmdir: 内部错误，无法删除 ${target}.`, 'error');
                    }
                }
            },
            'rm': {
                description: '删除文件或目录(使用 -r 递归删除)。用法: rm [-r] <目标>',
                execute: (args) => {
                    if (args.length === 0) {
                        writeOutput('rm: 缺少操作数。', 'error');
                        writeOutput('用法: rm [-r] <目标>', 'error');
                        return;
                    }                                                    
                    const flags = args.filter(arg => arg.startsWith('-'));
                    const targets = args.filter(arg => !arg.startsWith('-'));
                    const recursive = flags.includes('-r') || flags.includes('-R');                                
                    
                    if (targets.length === 0) { 
                          writeOutput('rm: 缺少操作目标。', 'error'); 
                          return;
                    }                                                            
                    targets.forEach(target => {
                        const { parentPath, targetName, targetAbsolutePath, parentNode } = resolvePath(target, currentPath);
                        
                        // 安全检查
                        if (targetAbsolutePath === '/' || targetAbsolutePath === '/home' || targetAbsolutePath === '/home/user') {
                            writeOutput(`rm: 危险操作，拒绝删除系统关键目录: ${targetAbsolutePath}`, 'error');
                            return;
                        }
                        if (target === '.' || target === '..') {
                            writeOutput(`rm: 拒绝删除特殊目录: ${target}`, 'error');
                            return;
                        }

                        const targetNode = getDirNode(targetAbsolutePath);

                        if (!targetNode) {
                            writeOutput(`rm: 目标不存在: ${target}`, 'error');
                            return;
                        }

                        if (targetNode.type === 'file') {
                            delete parentNode.contents[targetName];
                            writeOutput(`文件 ${targetName} 已删除。`);
                            return;
                        }

                        if (targetNode.type === 'dir') {
                            const isNonEmpty = Object.keys(targetNode.contents).length > 0;
                                                                                    
                            if (!recursive && isNonEmpty) {
                                writeOutput(`rm: 无法删除目录 '${targetName}': 目录非空。请使用 -r 选项。`, 'error');
                                return;
                            }                                                                                    
                            delete parentNode.contents[targetName];                                                                                    
                            if (recursive) {
                                writeOutput(`目录及其内容 ${targetName} 已递归删除。`);
                            } else {
                                writeOutput(`空目录 ${targetName} 已删除。`);
                            }
                            return;
                        }
                    });
                }
            },
            'linuxlogo': {
                description: '显示 logo 和系统信息。',
                execute: () => {
                    const logo = `      /\\ /\\         OS: Web-CLI FunOS (Simulated)
     ( ◕ ◕ )        Kernel: 5.15.0-js-web
   <  / ^ \\  >      Uptime: ${Math.floor(Math.random() * 5)} days, ${Math.floor(Math.random() * 24)} hours
    \\ \\_/ /       User: ${CLI_USER}
     '---'        CPU: Browser Core (x86_64)`;
                    writeOutput(logo, 'welcome');
                }
            },
            'cbonsai': {
                description: '模拟 cbonsai，使用 -l 查看可用方案。',
                execute: (args) => {
                    if (args.includes('-l')) {
                        const schemes = `可用方案列表 (模拟):
------------------------------------
  sakura  (樱花粉)
  bamboo  (竹绿色)
  ice     (冰蓝色)
  fire    (火焰红)
  matrix  (矩阵绿)
------------------------------------
使用 cbonsai <方案名> 模拟生成。`;
                        writeOutput(schemes);
                        return;
                    }
                    // 简单默认模式：显示一棵树
                    const tree = `     &&&|\\
                                        &&&&|/
                                           \\|&
                                            /|\\
                                            |/\\
                                           /|\\\\
                                           |//
                                          |/~
                                         |/
                                        |/
                             &         /~\\|
                             &&           /~
                         && & &&&&         /~|
                         & & &&&& \\__\\____\\_| /~\\
                        & & &&&\\&_\\          \\_~
                            \\___             /~/~
                              :___________./~~~\.___________:
                               \\                           / 
                                \\_________________________/ 
                                (_)                     (_)`;
                    writeOutput(tree);
                    writeOutput('cbonsai: 模拟盆栽已生长完毕。', 'welcome');
                }
            },
            'fortune': {
                description: '显示一句随机的箴言或名言。',
                execute: () => {
                    if (fortunes.length === 0) { 
                          writeOutput("fortune: 没有找到任何箴言。", 'error'); 
                          return;
                    }
                    const randomIndex = Math.floor(Math.random() * fortunes.length);
                    const quote = fortunes[randomIndex];                                                            
                    // 格式化输出
                    const line = '='.repeat(quote.length + 4);
                    writeOutput(`\n${line}`);
                    writeOutput(`| ${quote} |`);
                    writeOutput(`${line}\n`);
                }
            },
            'curl': {
                description: '模拟 HTTP GET 请求。用法: curl <URL>',
                execute: async (args) => {
                    if (args.length === 0) {
                        writeOutput('curl: 缺少 URL。', 'error');
                        writeOutput('用法: curl https://jsonplaceholder.typicode.com/todos/1', 'error');
                        return;
                    }
                    const url = args[0];                    
                    writeOutput(`正在连接到 ${url}...`);

                    input.disabled = true;                    
                    promptSpan.style.color = 'yellow';                    
                    promptSpan.innerText = 'FETCHING...';

                    try {                        
                        // 绕过 CORS，尝试获取数据
                        const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);                        
                        if (!response.ok) {                            
                            throw new Error(`HTTP 错误! 状态: ${response.status} ${response.statusText}`);
                        }                        
                        const data = await response.text();                                                 
                        
                        writeOutput(`--- curl 响应 (${url}) ---`);                        
                        const outputData = data.length > 500 ? data.substring(0, 500) + '... (输出被截断)' : data;                        
                        writeOutput(outputData);                        
                        writeOutput(`--- 状态: ${response.status} OK ---`);
                    } catch (error) {                        
                        writeOutput(`curl: 错误: ${error.message}`, 'error');                        
                        writeOutput('注意: 使用代理绕过 CORS 失败。请尝试公共 API。', 'error');
                    } finally {                        
                        input.disabled = false;                        
                        updatePrompt();                        
                        input.focus();                        
                        scrollToBottom();                        
                        promptSpan.style.color = 'var(--prompt-color)';
                    }
                }
            },
            'ping': {
                description: '测试网络连接到主机。用法: ping <URL>',
                execute: async (args) => {
                    if (args.length === 0) {
                        writeOutput('ping: 缺少主机名或 URL。', 'error');
                        writeOutput('用法: ping https://www.google.com', 'error');
                        return;
                    }
                    const target = args[0];                    
                    const count = 4;                    
                    let successCount = 0;

                    writeOutput(`PING ${target}. 模拟发送 ${count} 个数据包...`);                                                            
                    input.disabled = true;                    
                    promptSpan.style.color = 'yellow';                    
                    promptSpan.innerText = 'Pinging...';

                    for (let i = 1; i <= count; i++) {                        
                        const startTime = performance.now();                        
                        let status = 'Error';                                                
                        
                        try {                            
                            // 使用 HEAD/no-cors 模拟网络尝试                            
                            await fetch(target, { method: 'HEAD', mode: 'no-cors' });                             
                            status = 'Success';                            
                            successCount++;
                        } catch (error) {                            
                            status = `Destination Host Unreachable.`;
                        }                                                
                        
                        const endTime = performance.now();                        
                        // 模拟随机延迟                        
                        const latency = (endTime - startTime + Math.random() * 50).toFixed(2); 

                        let result = '';                        
                        if (status === 'Success') {                            
                            result = `来自 ${target} 的回复: bytes=32 时间=${latency}ms TTL=${(Math.random() * 100).toFixed(0)}`;
                        } else {                            
                            result = `请求超时或连接失败: ${status}`;
                        }                        
                        writeOutput(result);

                        await new Promise(resolve => setTimeout(resolve, 800));                    
                    }

                    const loss = ((count - successCount) / count * 100).toFixed(0);                    
                    writeOutput(`\n--- ${target} ping 统计信息 ---`);                    
                    writeOutput(`${count} 个数据包已发送, ${successCount} 个已接收, ${count - successCount} 个丢失 (${loss}% 丢失)`);                                        
                    
                    input.disabled = false;                    
                    updatePrompt();                    
                    input.focus();                    
                    scrollToBottom();                    
                    promptSpan.style.color = 'var(--prompt-color)';
                }
            },
            // 新增 NCAT 命令            
            'ncat': {
                description: '模拟网络连接和端口扫描。用法: ncat <host> <port>',
                execute: async (args) => {
                    if (args.length < 2) {
                        writeOutput('ncat: 缺少主机和端口。', 'error');
                        writeOutput('用法: ncat example.com 80', 'error');
                        return;
                    }
                    const host = args[0];                    
                    const port = parseInt(args[1]);

                    writeOutput(`Ncat: 正在连接 ${host}:${port}...`);                    
                    input.disabled = true;                    
                    promptSpan.style.color = 'yellow';                    
                    promptSpan.innerText = 'CONNECTING...';                                        
                    await new Promise(resolve => setTimeout(resolve, 1500)); // 模拟延迟

                    let result = '';                                        
                    if (port === 80 || port === 443 || port === 22) {
                        // 模拟标准服务连接成功                        
                        result = `Ncat: Connection successful to ${host}:${port}.\n`;                        
                        if (port === 80) result += 'GET / HTTP/1.1\nHost: example.com\n\n';                        
                        if (port === 443) result += 'Encrypted tunnel established (Simulated TLS).\n';                        
                        if (port === 22) result += 'SSH-2.0-OpenSSH_9.0p1 Debian-1:9.0p1-1 (Simulated banner)\n';

                        writeOutput(result, 'welcome');                        
                        writeOutput('模拟连接已建立。按 Ctrl+C 退出 (在实际终端中)。');                                            
                    } else if (port >= 1 && port <= 65535 && (Math.random() < 0.2 || port === 23)) {
                        // 模拟一些随机开放的端口 (20% 概率) 或 Telnet (23)                        
                        writeOutput(`Ncat: Connected to ${host}:${port}. Port appears open.`, 'welcome');                        
                        if (port === 23) writeOutput('Trying to escape Telnet... (Simulated Telnet session)');
                    } else {
                        // 模拟连接失败/拒绝                        
                        writeOutput(`Ncat: Connection refused to ${host}:${port}.`, 'error');
                    }

                    input.disabled = false;                    
                    updatePrompt();                    
                    input.focus();                    
                    scrollToBottom();                    
                    promptSpan.style.color = 'var(--prompt-color)';
                }
            },                        
            // 新增 DISPLAY 命令            
            'display': {
                description: '在浏览器中显示图像。用法: display <URL>',
                execute: (args) => {
                    if (args.length === 0) {
                        writeOutput('display: 缺少图像源。', 'error');
                        writeOutput('用法: display https://example.com/image.jpg', 'error');
                        return;
                    }

                    const source = args[0];
                    
                    if (source.startsWith('http://') || source.startsWith('https://')) {
                        // 尝试显示外部 URL
                        writeOutput(`display: 尝试加载远程图像 ${source}...`, 'welcome');
                        
                        const imageHtml = `
                            <p>图像预览 (通过浏览器加载):</p>
                            <a href="${source}" target="_blank" style="color:var(--dir-color);">点击在新标签页打开图像</a>
                            <img src="${source}" onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'200\\' height=\\'100\\'><rect width=\\'200\\' height=\\'100\\' fill=\\'#333\\'/><text x=\\'100\\' y=\\'55\\' font-family=\\'monospace\\' font-size=\\'12\\' fill=\\'#ff0000\\' text-anchor=\\'middle\\'>加载失败或URL无效</text></svg>';" alt="Displayed Image"/>
                        `;
                        writeHtmlOutput(imageHtml);

                    } else if (source.startsWith('/')) {
                        // 模拟本地文件查找
                        const node = getDirNode(source);
                        if (node && node.type === 'file' && (node.name.endsWith('.png') || node.name.endsWith('.jpg') || node.name.endsWith('.mp3') || node.name.endsWith('.txt'))) {
                            writeOutput(`display: 找到本地文件 ${source}。`, 'welcome');
                            writeOutput('提示: 模拟终端无法直接访问并显示本地文件内容。', 'error');
                        } else {
                            writeOutput(`display: 文件不存在或不是支持的图像/文本格式: ${source}`, 'error');
                        }
                    } else {
                         writeOutput(`display: 不支持的图像源格式。请使用完整的 URL 或文件路径。`, 'error');
                    }
                }
            },
            // 新增 GKRELLM 命令
            'gkrellm': {
                description: '模拟 GKrellM 系统监视器。Ctrl+C 退出。',
                execute: (args) => {
                    if (gkrellmIntervalId !== null) {
                        writeOutput('gkrellm 已经在运行。请按 Ctrl+C 退出。', 'error');
                        return;
                    }

                    output.innerHTML = ''; // 清空屏幕，模拟进入全屏应用
                    writeOutput('正在启动 GKrellM 模拟器...', 'welcome');
                    
                    const gkrellmDiv = document.createElement('div');
                    gkrellmDiv.id = 'gkrellm-monitor';
                    output.appendChild(gkrellmDiv);

                    input.disabled = true;
                    promptSpan.innerText = 'MONITORING... (按 Ctrl+C 停止)';
                    promptSpan.style.color = '#ff00ff'; 
                    
                    let cpuUsage = 15;
                    let memUsage = 60;
                    let netRx = 0.1;
                    let netTx = 0.05;

                    const refreshMonitor = () => {
                        // 模拟数据波动
                        cpuUsage = Math.min(100, Math.max(5, cpuUsage + (Math.random() * 8 - 4)));
                        memUsage = Math.min(95, Math.max(50, memUsage + (Math.random() * 2 - 1)));
                        netRx = Math.max(0.01, netRx + (Math.random() * 0.2 - 0.1));
                        netTx = Math.max(0.01, netTx + (Math.random() * 0.1 - 0.05));

                        const cpuBar = '█'.repeat(Math.round(cpuUsage / 10)).padEnd(10, '░');
                        const memBar = '█'.repeat(Math.round(memUsage / 10)).padEnd(10, '░');

                        const monitorAscii = `
┌───────────────────────────┐
│ Web-CLI GKrellM Simulator │
├───────────────────────────┤
│ Uptime: ${new Date().toLocaleTimeString()}     │
│ Load: 0.50 0.45 0.40        │
├───────────────────────────┤
│ CPU: [${cpuBar}] ${cpuUsage.toFixed(1).padEnd(5, ' ')}%     │
│ Memory: [${memBar}] ${memUsage.toFixed(1).padEnd(5, ' ')}%    │
│ Swap: [░░░░░░░░░░] 0.0%    │
├───────────────────────────┤
│ Net I/F: eth0 (Simulated) │
│   Rx: ${netRx.toFixed(2).padEnd(5, '0')} MB/s (${(netRx * 8 * 10).toFixed(1)} Mb/s) │
│   Tx: ${netTx.toFixed(2).padEnd(5, '0')} MB/s (${(netTx * 8 * 10).toFixed(1)} Mb/s) │
├───────────────────────────┤
│ FS: /home/user (Sim) 20G/50G│
└───────────────────────────┘
`;
                        gkrellmDiv.textContent = monitorAscii;
                        scrollToBottom();
                    };

                    refreshMonitor();
                    gkrellmIntervalId = setInterval(refreshMonitor, 1000);
                }
            },
            // 新增 GIFWRAP 命令
            'gifwrap': {
                description: '模拟在终端中播放 ASCII 动画。Ctrl+C 退出。',
                execute: () => {
                    if (gifwrapIntervalId !== null) {
                        writeOutput('gifwrap 已经在运行。请按 Ctrl+C 退出。', 'error');
                        return;
                    }

                    output.innerHTML = ''; // 清空屏幕
                    writeOutput('正在启动 GIFWRAP 动画...', 'welcome');
                    
                    const gifwrapDiv = document.createElement('div');
                    gifwrapDiv.id = 'gifwrap-animation';
                    output.appendChild(gifwrapDiv);

                    input.disabled = true;
                    promptSpan.innerText = 'ANIMATING... (按 Ctrl+C 停止)';
                    promptSpan.style.color = '#ff8000'; // 动画模式颜色
                    
                    // ASCII 动画帧 (模拟一个跳动的方块)
                    const frames = [
                        `
  (^_^)/
   | |
  / \\
`,
                        `
  \\(^_^)/
    | |
   / \\
`,
                        `
  /(^_^)\\
   | |
  / \\
`,
                        `
  (^_^)\\
   | |
  / \\
`
                    ];

                    let currentFrame = 0;

                    const refreshAnimation = () => {
                        currentFrame = (currentFrame + 1) % frames.length;
                        gifwrapDiv.textContent = frames[currentFrame];
                        scrollToBottom();
                    };

                    gifwrapIntervalId = setInterval(refreshAnimation, 150);
                }
            }
        };

        // --- 事件监听和初始化 ---
        function handleInput() {
            const commandLine = input.value.trim();
            if (commandLine === '') return;

            writeCommandHistory(commandLine);
            history.push(commandLine);
            historyIndex = history.length; 

            const parts = commandLine.split(/\s+/);
            const command = parts[0].toLowerCase();
            const args = parts.slice(1);

            const cmd = commands[command];
            if (cmd) {
                // 异步命令 (curl, ping, ncat, gkrellm, gifwrap) 在内部清空输入并处理焦点
                if (command === 'curl' || command === 'ping' || command === 'ncat' || command === 'gkrellm' || command === 'gifwrap') {
                    cmd.execute(args);
                } else {
                    cmd.execute(args);
                    input.value = '';
                    input.focus();
                }
            } else {
                writeOutput(`命令未找到: ${command}. 输入 'help' 查看命令。`, 'error');
                input.value = '';
                input.focus();
            }
        }                

        // 欢迎信息
        function writeWelcome() {
            writeOutput('', '');
            writeOutput('', '');
            writeOutput('', '');
            writeOutput('', '');
        }

        input.addEventListener('keydown', (e) => {
            // 监听 Ctrl+C 组合键
            if ((e.key === 'c' || e.key === 'C') && e.ctrlKey) {
                if (gkrellmIntervalId !== null || gifwrapIntervalId !== null) {
                    e.preventDefault(); // 阻止浏览器默认的复制行为
                    
                    // 清理 gkrellm 定时器
                    if (gkrellmIntervalId !== null) {
                        clearInterval(gkrellmIntervalId);
                        gkrellmIntervalId = null;
                    }
                    // 清理 gifwrap 定时器
                    if (gifwrapIntervalId !== null) {
                        clearInterval(gifwrapIntervalId);
                        gifwrapIntervalId = null;
                    }
                    
                    output.innerHTML = ''; // 清空动画屏幕
                    writeOutput('^C', 'error'); // 模拟 Ctrl+C 提示
                    writeOutput('动画/监视器已停止。', 'welcome');
                    
                    input.disabled = false;
                    updatePrompt();
                    input.focus();
                    promptSpan.style.color = 'var(--prompt-color)';
                    return;
                }
            }

            if (e.key === 'Enter') {
                if (input.disabled) return; 
                handleInput();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = history[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    input.value = history[historyIndex];
                } else {
                    historyIndex = history.length;
                    input.value = '';
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                if (!input.disabled) {
                    autoComplete();
                }
            }
        });

        document.getElementById('terminal-container').addEventListener('click', () => {
            if (!input.disabled) {
                input.focus();
            }
        });

        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            updatePrompt();
            writeWelcome();
            input.focus();
        });
    </script>
</body>
</html>
