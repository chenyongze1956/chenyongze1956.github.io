
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal CLI (è¶…å…¨åŠŸèƒ½ - é­”æ³•ç‰ˆ)</title>
    <style>
        /* [CSS Styles for Terminal Look and Feel] */
        @keyframes rainbow-color-change {
            0%, 100% { color: #ff0000; }
            14% { color: #ff8b00; }
            28% { color: #e8ff00; }
            56% { color: #00b9ff; }
            42% { color: #5dff00; }
            70% { color: #5d00ff; }
            84% { color: #e800ff; }
        }
        * {
            box-sizing: border-box;
        }
        :root {
            --terminal-bg: #000000;
            --terminal-text: #00ff00; /* Bright Green */
            --prompt-color: #00ffff; /* Cyan for the prompt text */
            --dir-color: #33ccff; /* Blue for directories */
            --file-color: #ffffff; /* White for files */
            --terminal-width-desktop: 800px;
            --terminal-height-desktop: 600px;
            --font-size-desktop: 1rem;
            --font-size-mobile: 0.9rem;
        }
        body {
            background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            font-family: Comic Sans MS, cursive, sans-serif;
            color: var(--terminal-text);
            font-size: var(--font-size-desktop);
            animation: rainbow-color-change 3s linear infinite alternate;
        }
        #terminal-container {
            position: relative;
            background-color: var(--terminal-bg);
            width: 100%;
            max-width: var(--terminal-width-desktop);
            height: 100vh;
            max-height: var(--terminal-height-desktop);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            display: flex;
            flex-direction: column;
            color: var(--terminal-text);
            font-family: monospace;
            font-size: var(--font-size-desktop);
            z-index: 100;
            transition: box-shadow 0.5s ease-in-out, background-color 0.5s ease-in-out; 
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-break: break-all;
            position: relative;
            z-index: 2;
        }
        #output::-webkit-scrollbar { width: 8px; }
        #output::-webkit-scrollbar-track { background: #222; }
        #output::-webkit-scrollbar-thumb { background: #004d00; border-radius: 4px; }
        #output::-webkit-scrollbar-thumb:hover { background: var(--terminal-text); }
        #input-line {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-top: 1px solid #004d00;
            flex-shrink: 0;
            position: relative;
            z-index: 3;
        }
        #prompt {
            color: var(--prompt-color);
            margin-right: 8px;
            flex-shrink: 0;
            transition: color 0.3s;
        }
        #commandInput {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--terminal-text);
            font-family: inherit;
            font-size: inherit;
            outline: none;
            caret-color: var(--terminal-text);
            padding: 0;
            margin: 0;
        }
        .output-line { margin: 0; }
        .output-line span { color: var(--prompt-color); }
        .error { color: #ff4500; }
        .welcome { color: #ffff00; margin-bottom: 10px; }
        .dir { color: var(--dir-color); font-weight: bold; }
        .file { color: var(--file-color); }
        .output-line img {
            max-width: 100%;
            height: auto;
            margin-top: 10px;
            border: 1px solid #00ff00;
            display: block;
        }
        #sl-train-animation, #gifwrap-animation, #gkrellm-monitor, #cbonsai-animation, #mplayer-progress {
            white-space: pre;
            font-family: monospace;
        }
        .qr-code-ascii {
            font-family: monospace;
            line-height: 0.7;
            color: #ffffff;
            white-space: pre;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .ruler-ascii {
            font-family: monospace;
            white-space: pre;
            color: #ff8000;
            margin: 5px 0;
        }
        #xsnow-container {            
            position: fixed; 
            top: 0;
            left: 0;
            width: 100vw; 
            height: 100vh; 
            pointer-events: none; 
            overflow: hidden;
            z-index: 99999; 
            opacity: 0.8; 
            display: none; 
        }        
        @keyframes fall {            
            0% { transform: translateY(-5%) translateX(0) rotate(0deg); }            
            50% { transform: translateY(50vh) translateX(5vw); }            
            100% { transform: translateY(105vh) translateX(0) rotate(360deg); }        
        }        
        .snowflake {            
            animation-name: fall;            
            animation-timing-function: linear;            
            animation-iteration-count: infinite;            
            animation-direction: normal;            
            animation-fill-mode: forwards;            
            position: absolute; 
            color: white; 
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); 
        }
        @media (max-width: 768px) {
            body { font-size: var(--font-size-mobile); padding: 0; }
            #terminal-container { border-radius: 0; height: 100vh; }
            #output { padding: 10px; }
            #input-line { padding: 8px 10px; }
        }
    </style>
</head>
<body>
    <div id="xsnow-container"></div>
    <div id="terminal-container">
        <div id="output">
        </div>
        <div id="input-line">
            <span id="prompt">user@web-cli:~$</span>
            <input type="text" id="commandInput" autofocus>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('commandInput');
        const promptSpan = document.getElementById('prompt');
        const terminalContainer = document.getElementById('terminal-container');
        const initialPromptText = "user@web-cli:";
        const CLI_USER = 'web-cli-user';
                                
        let history = [];
        let historyIndex = -1;
        let currentPath = '/home/user';
        let isLumosActive = false; // é­”æ³•åŠŸèƒ½æ‰€éœ€
        let isChatMode = false; // chat æ¨¡å¼å¼€å…³
        let chatHistory = []; 
        let isCtrlCBlocked = false; 

        // --- å…¨å±€å®šæ—¶å™¨ ID åˆ—è¡¨ ---
        let activeIntervals = [];

        function clearAllIntervals() {
            activeIntervals.forEach(id => clearInterval(id));
            activeIntervals = [];
        }

        function clearAllTimeouts() {
            // æ¸…é™¤å„ç§åŠ¨ç”»å’Œæ¨¡æ‹Ÿè¿›ç¨‹
            const xsnowContainer = document.getElementById('xsnow-container');
            if (xsnowContainer) {
                xsnowContainer.style.display = 'none';
                xsnowContainer.innerHTML = '';
            }
            
            // é‡ç½® Ctrl+C
            isCtrlCBlocked = false;
        }
        // ----------------------
                                
        // --- å…¨å±€æ•°æ® (Fortunes, fileSystem, etc.) ---        
        const fortunes = [
            "çŸ¥è€…ä¸è¨€ï¼Œè¨€è€…ä¸çŸ¥ã€‚", "äººç”Ÿå°±åƒä¸€ç›’å·§å…‹åŠ›ï¼Œä½ æ°¸è¿œä¸çŸ¥é“ä¸‹ä¸€å—ä¼šæ˜¯ä»€ä¹ˆå‘³é“ã€‚",
            "é‡è¦çš„ä¸æ˜¯ä½ ç«™çš„ä½ç½®ï¼Œè€Œæ˜¯ä½ æœå‘çš„æ–¹å‘ã€‚", "æˆ‘ä»¬æœ€å¤§çš„è£è€€ä¸åœ¨äºæ°¸ä¸è·Œå€’ï¼Œè€Œåœ¨äºæ¯æ¬¡è·Œå€’åéƒ½èƒ½ç«™èµ·æ¥ã€‚",
        ];
        // æ–‡ä»¶ç³»ç»Ÿ
        const fileSystem = {
            name: '/',
            type: 'dir',
            contents: {
                'home': {
                    name: 'home', type: 'dir', contents: {
                        'user': {
                            name: 'user', type: 'dir', contents: {
                                'Documents': { name: 'Documents', type: 'dir', contents: {} },
                                'Images': { name: 'Images', type: 'dir', contents: {} },
                                'music.mp3': { name: 'music.mp3', type: 'file', locked: true }, // é»˜è®¤é”å®š
                                'README.txt': { name: 'README.txt', type: 'file' }
                            }
                        }
                    }
                },
                'etc': { name: 'etc', type: 'dir', contents: { 'hosts': { name: 'hosts', type: 'file' } } },
                'bin': { name: 'bin', type: 'dir', contents: {} }
            }
        };
                
        // --- è¾…åŠ©å‡½æ•° (æ–‡ä»¶ç³»ç»Ÿ, I/O) ---        
        function getDirNode(path) {
            let parts = path.split('/').filter(p => p.length > 0);
            let currentNode = fileSystem;                    
            
            for (const part of parts) {
                if (currentNode.contents && currentNode.contents[part]) {
                    currentNode = currentNode.contents[part];
                } else {
                    return null;                            
                }
            }
            return currentNode;
        }

        function getCurrentDirNode() { return getDirNode(currentPath); }

        function updatePrompt() {
            const promptPrefix = isChatMode ? `AI_Session` : initialPromptText;
            const promptSuffix = isChatMode ? ' >' : `~$`;
            promptSpan.innerText = `${promptPrefix}:${currentPath}${promptSuffix}`;
        }                
        
        function writeOutput(text, className = 'output-text') {
            const lines = text.split('\n');
            lines.forEach(line => {
                const p = document.createElement('p');
                p.className = `output-line ${className}`;
                p.textContent = line;
                output.appendChild(p);
            });
            scrollToBottom();
        }                

        function writeHtmlOutput(htmlContent) {
            const p = document.createElement('p');
            p.className = 'output-line';
            p.innerHTML = htmlContent;
            output.appendChild(p);
            scrollToBottom();
        }

        function writeCommandHistory(commandLine) {
            const p = document.createElement('p');
            p.className = 'output-line';
            p.innerHTML = `<span style="color:var(--prompt-color);">${promptSpan.innerText}</span> ${commandLine}`;
            output.appendChild(p);
        }

        function scrollToBottom() { output.scrollTop = output.scrollHeight; }
        
        // --- æ ¸å¿ƒ AI/å åœ/å·¥å…· è¾…åŠ©å‡½æ•° ---
        
        // 1. æ¨¡æ‹Ÿ AI é—®ç­”
        function simulateAiResponse(query) {
             const lowQuery = query.toLowerCase();
             if (lowQuery.includes('æ—¶é—´')) return `å½“å‰çš„æ—¶é—´æ˜¯ ${new Date().toLocaleString()}ã€‚`;
             if (lowQuery.includes('ä½ æ˜¯è°')) return 'æˆ‘æ˜¯ä¸€ä¸ªåŸºäº JavaScript æ¨¡æ‹Ÿçš„ AI æ¨¡å‹ï¼Œè¿è¡Œåœ¨ Web-CLI ç»ˆç«¯ç¯å¢ƒä¸­ã€‚';
             if (lowQuery.includes('ä½ å¥½')) return 'å¾ˆé«˜å…´èƒ½ä¸ºæ‚¨æœåŠ¡ã€‚';
             const genericResponses = ['è¿™æ˜¯ä¸€ä¸ªæ·±åˆ»çš„é—®é¢˜ã€‚', 'æˆ‘æ­£åœ¨å¤„ç†å¤§é‡æ•°æ®ä»¥æ‰¾åˆ°æœ€ä¼˜è§£ã€‚', 'æˆ‘å°†æ­¤æ ‡è®°ä¸ºæœªæ¥çš„è®­ç»ƒæ•°æ®ã€‚'];
             return genericResponses[Math.floor(Math.random() * genericResponses.length)];
        }

        // 2. æ¨¡æ‹Ÿé‡‘èæ•°æ®
        const stockData = { 'AAPL': { price: 175.42, change: 1.25, sector: 'Tech' }, 'GOOG': { price: 139.88, change: -0.55, sector: 'Tech' } };
        const cryptoData = { 'BTC': 42000.50, 'ETH': 2200.75, 'DOGE': 0.085 };
        const fxRates = { 'USD': { 'EUR': 0.92, 'JPY': 145.0, 'CNY': 7.15 }, 'EUR': { 'USD': 1.09 }, 'JPY': { 'USD': 0.0069 } };

        // 3. æ¨¡æ‹Ÿå…­çˆ»å åœ
        function throwCoins() { return Math.floor(Math.random() * 2) + 2 + Math.floor(Math.random() * 2) + 2 + Math.floor(Math.random() * 2) + 2; }
        const yaoMap = { 6: { symbol: 'X', isMoving: true, name: 'è€é˜´ (åŠ¨)' }, 7: { symbol: 'â€”', isMoving: false, name: 'å°‘é˜³' }, 8: { symbol: '--', isMoving: false, name: 'å°‘é˜´' }, 9: { symbol: 'O', isMoving: true, name: 'è€é˜³ (åŠ¨)' } };
        function getYaoSymbol(yaoValue) { return yaoMap[yaoValue] ? yaoMap[yaoValue].symbol : '??'; }
        const simplifiedHexagrams = [
            { code: 1, name: 'ä¹¾ä¸ºå¤© (åˆ›é€ )', message: 'å¤§å‰ã€‚æ—¶æœºæˆç†Ÿï¼ŒæŠŠæ¡ä¸»åŠ¨æƒï¼Œä¸€åˆ‡é¡ºåˆ©ã€‚' },
            { code: 3, name: 'å±¯å¦ (è‰°éš¾)', message: 'æœ‰é˜»ç¢ã€‚åˆæœŸå›°éš¾ï¼Œéœ€åšå¿ä¸æ‹”ã€‚' },
            { code: 5, name: 'éœ€å¦ (ç­‰å¾…)', message: 'ç­‰å¾…æ—¶æœºã€‚å®œé™ä¸å®œåŠ¨ï¼Œå‡†å¤‡å……åˆ†ã€‚' },
            { code: 30, name: 'ç¦»ä¸ºç« (å…‰æ˜)', message: 'é¡ºåˆ©ã€‚å‰æ™¯å…‰æ˜ï¼Œä½†éœ€ä¿æŒè­¦æƒ•ã€‚' }
        ];
        function generateHexagram() {
            let hexagram = []; for (let i = 0; i < 6; i++) { hexagram.push(throwCoins()); }
            return { hexagram, changingHexagram: hexagram.map(val => yaoMap[val].isMoving ? (val === 6 ? 7 : 8) : val) };
        }
        function analyzeHexagram(hexagram) {
            const mainHex = simplifiedHexagrams[Math.floor(Math.random() * simplifiedHexagrams.length)];
            return { hexagramName: mainHex.name, oracleMessage: mainHex.message };
        }

        // 4. äºŒç»´ç ç”Ÿæˆ (QR Code ASCII) - ä¿®å¤äº† `qr.isModule` çš„è¯­æ³•é”™è¯¯
        function qrCodeToAscii(text) {
            try {
                const qr = qrcode(0, 'L');
                qr.addData(text);
                qr.make();
                
                const modules = qr.getModuleCount();
                let ascii = '';
                
                for (let y = 0; y < modules; y++) {
                    for (let x = 0; x < modules; x++) {
                        // ä¿®æ­£åçš„ä»£ç 
                        ascii += qr.isModule(x, y) ? 'â–ˆâ–ˆ' : '  '; 
                    }
                    ascii += '\n';
                }
                return ascii;
            } catch (e) {
                return 'qrterminal: ç”ŸæˆäºŒç»´ç å¤±è´¥ã€‚';
            }
        }

        // 5. å¯†ç ç”Ÿæˆ (PWGEN)
        function generatePassword(length) {
            const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+";
            let password = '';
            for (let i = 0; i < length; i++) {
                password += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return password;
        }

        // --- åŠ¨ç”»/æ¨¡æ‹Ÿè¿›ç¨‹è¾…åŠ©å‡½æ•° (ç”¨äº sl, gkrellm, gifwrap, mplayer, xsnow) ---

        function handleCtrlC() {
             if (isCtrlCBlocked) {
                clearAllTimeouts();
                clearAllIntervals();
                writeOutput("^C\nè¿›ç¨‹å·²ç»ˆæ­¢ã€‚", 'error');
                isCtrlCBlocked = false;
             }
        }
        
        // 1. GKrellM æ¨¡æ‹Ÿ
        function startGkrellm() {
            let cpu = 50, mem = 30, net = 0;
            const gkrellmElement = document.createElement('pre');
            gkrellmElement.id = 'gkrellm-monitor';
            output.appendChild(gkrellmElement);

            const update = () => {
                cpu = Math.max(1, Math.min(100, cpu + (Math.random() > 0.5 ? 5 : -5)));
                mem = Math.max(10, Math.min(80, mem + (Math.random() > 0.5 ? 2 : -2)));
                net += Math.floor(Math.random() * 10) + 1;
                
                const cpuBar = 'â–ˆ'.repeat(Math.floor(cpu / 5)).padEnd(20, 'â–‘');
                const memBar = 'â–ˆ'.repeat(Math.floor(mem / 5)).padEnd(20, 'â–‘');

                gkrellmElement.textContent = `
--[ Web-CLI Monitor ]--
CPU: ${cpu.toFixed(1)}% [${cpuBar}]
MEM: ${mem.toFixed(1)}% [${memBar}]
NET: Total: ${net} MB (â†‘ 0.5 MB/s)
Uptime: ${Math.floor(Date.now() / 1000000)}m
-----------------------
                `.trim();
                scrollToBottom();
            };
            
            const intervalId = setInterval(update, 1000);
            activeIntervals.push(intervalId);
            isCtrlCBlocked = true;
            update();
            writeOutput("GKrellM æ¨¡æ‹Ÿè¿è¡Œä¸­... æŒ‰ Ctrl+C åœæ­¢ã€‚");
        }
        
        // 2. sl è’¸æ±½ç«è½¦æ¨¡æ‹Ÿ
        function startSl() {
            const train = `
        _o_o
      _/\_/\_/\_
   __I--I--I--I__
  /______________\\
 |________________|
  \\@@@@@@@@@@@@@@/
   '--'--'--'--' 
            `;
            const lines = train.split('\n');
            let position = 0;
            const terminalWidth = 80;
            const slElement = document.createElement('pre');
            slElement.id = 'sl-train-animation';
            output.appendChild(slElement);
            
            const update = () => {
                let frame = '';
                for(const line of lines) {
                    const spaces = ' '.repeat(position);
                    frame += spaces + line + '\n';
                }
                slElement.textContent = frame.trim();
                position++;
                
                if (position > terminalWidth) {
                    position = -20; 
                }
                scrollToBottom();
            };
            
            const intervalId = setInterval(update, 150);
            activeIntervals.push(intervalId);
            isCtrlCBlocked = true;
            writeOutput("sl è’¸æ±½ç«è½¦æ¨¡æ‹Ÿè¿è¡Œä¸­... æŒ‰ Ctrl+C åœæ­¢ã€‚");
        }

        // 3. gifwrap/cbonsai æ¨¡æ‹Ÿ
        function startSimpleAnimation(cmd, frames, speed = 300) {
            let frameIndex = 0;
            const animElement = document.createElement('pre');
            animElement.id = `${cmd}-animation`;
            output.appendChild(animElement);

            const update = () => {
                animElement.textContent = frames[frameIndex].trim();
                frameIndex = (frameIndex + 1) % frames.length;
                scrollToBottom();
            };
            
            const intervalId = setInterval(update, speed);
            activeIntervals.push(intervalId);
            isCtrlCBlocked = true;
            writeOutput(`${cmd} æ¨¡æ‹Ÿè¿è¡Œä¸­... æŒ‰ Ctrl+C åœæ­¢ã€‚`);
        }

        function startGifwrap(args) {
             const frames = ["  ( â€¢_â€¢)>âŒâ– -â–  ", "   (âŒâ– _â– )     "];
            startSimpleAnimation('gifwrap', frames, 500);
        }

        function startCbonsai() {
            const frames = [
`    /\\
   /  \\
  /|  |\\
   |__|
    \/
    `,
`    /\\
   /--\\
  /|\\/|\\
  |/--\\|
   |__|
    \/
    `,
`     /\\
    /~~\\
   /|/\\|\\
  |/\\/\\/\\|
   |---|
     |
`
            ];
            startSimpleAnimation('cbonsai', frames, 800);
        }

        // 4. mplayer æ¨¡æ‹Ÿ
        function startMplayer(url) {
            let progress = 0;
            const duration = 120;
            const mplayerElement = document.createElement('pre');
            mplayerElement.id = 'mplayer-progress';
            output.appendChild(mplayerElement);

            const update = () => {
                if (progress >= duration) {
                    mplayerElement.textContent = `Playing ${url} done.`;
                    handleCtrlC(); 
                    return;
                }
                
                const percentage = Math.floor((progress / duration) * 100);
                const barLength = Math.floor(percentage / 5);
                const progressBar = `[${'#'.repeat(barLength)}${'-'.repeat(20 - barLength)}]`;
                
                mplayerElement.textContent = `
MPlayer 1.0rc4 (simulated)
Playing ${url} (Audio/Video).
${progressBar} ${percentage}% Time: ${progress}s / ${duration}s
                `.trim();
                progress += 5;
                scrollToBottom();
            };
            
            const intervalId = setInterval(update, 500);
            activeIntervals.push(intervalId);
            isCtrlCBlocked = true;
            writeOutput(`mplayer æ¨¡æ‹Ÿæ’­æ”¾ ${url} ä¸­... æŒ‰ Ctrl+C åœæ­¢ã€‚`);
        }


        // 5. xsnow é™é›ªæ¨¡æ‹Ÿ
        function startXsnow() {
            const container = document.getElementById('xsnow-container');
            container.style.display = 'block';
            isCtrlCBlocked = true;
            
            const createSnowflake = () => {
                const snowflake = document.createElement('span');
                snowflake.className = 'snowflake';
                snowflake.innerHTML = ['*', 'â€¢', 'â…', 'â„'][Math.floor(Math.random() * 4)];
                
                const size = Math.random() * 10 + 10; 
                snowflake.style.fontSize = `${size}px`;
                snowflake.style.left = `${Math.random() * 100}vw`;
                snowflake.style.animationDuration = `${Math.random() * 10 + 5}s`;
                snowflake.style.animationDelay = `-${Math.random() * 10}s`;
                snowflake.style.opacity = `${Math.random()}`;
                
                container.appendChild(snowflake);
                setTimeout(() => {
                    if (snowflake.parentElement === container) {
                         snowflake.remove();
                    }
                }, parseFloat(snowflake.style.animationDuration) * 1000 + 1000); 
            };

            for (let i = 0; i < 50; i++) { createSnowflake(); }

            const intervalId = setInterval(createSnowflake, 500);
            activeIntervals.push(intervalId);
            writeOutput("â„ï¸ xsnow é™é›ªæ¨¡æ‹Ÿå·²å¯åŠ¨ã€‚æŒ‰ Ctrl+C åœæ­¢ã€‚", 'welcome');
        }


        // --- é­”æ³•åŠŸèƒ½å®ç° (Lumos, Alohomora, Expecto Patronum) ---

        function castLumos(args) {
            const defaultBg = '#000000';
            const defaultShadow = '0 0 20px rgba(0, 255, 0, 0.3)';
            const defaultText = '#00ff00';
            const defaultPrompt = '#00ffff';
            const lumosBg = '#ffffff';
            const lumosShadow = '0 0 40px rgba(255, 255, 255, 0.8)';
            const lumosText = '#0000ff';
            const lumosPrompt = '#ff00ff';


            if (args[0] && args[0].toLowerCase() === 'nox') {
                terminalContainer.style.setProperty('box-shadow', defaultShadow);
                terminalContainer.style.setProperty('background-color', defaultBg);
                document.documentElement.style.setProperty('--terminal-text', defaultText);
                document.documentElement.style.setProperty('--prompt-color', defaultPrompt);
                isLumosActive = false;
                writeOutput("âœ¨ Nox! å…‰èŠ’ç†„ç­ï¼Œç»ˆç«¯æ¢å¤é»‘æš—ã€‚", 'welcome');
                return;
            }
            
            terminalContainer.style.setProperty('box-shadow', lumosShadow);
            terminalContainer.style.setProperty('background-color', lumosBg);
            document.documentElement.style.setProperty('--terminal-text', lumosText);
            document.documentElement.style.setProperty('--prompt-color', lumosPrompt);
            isLumosActive = true;
            writeOutput("âœ¨ Lumos! ç»ˆç«¯è¢«ç…§äº®ï¼Œå…‰èŠ’ä¸‡ä¸ˆï¼è¯•è¯• 'cast nox' å…³é—­ã€‚", 'welcome');
        }

        function castAlohomora() {
            const targetNode = getCurrentDirNode();
            let targetFile = null;

            if (!targetNode || targetNode.type !== 'dir') {
                 writeOutput(`Alohomora: æ— æ³•åœ¨æ­¤å¤„æ–½æ³•ã€‚`, 'error');
                 return;
            }

            for (const key in targetNode.contents) {
                if (targetNode.contents[key].locked) {
                    targetFile = targetNode.contents[key];
                    break;
                }
            }

            if (targetFile) {
                targetFile.locked = false; // è§£é”
                writeOutput(`ğŸ”“ Alohomora! æ–‡ä»¶ ${targetFile.name} ä¸Šçš„é­”æ³•é”å·²è¢«è§£é™¤ï¼ç°åœ¨å¯ä»¥ä½¿ç”¨ 'rm ${targetFile.name}' åˆ é™¤äº†ã€‚`, 'welcome');
            } else {
                writeOutput(`Alohomora: æ²¡æœ‰æ‰¾åˆ°éœ€è¦è§£é”çš„ç‰©å“ã€‚`, 'error');
            }
        }

        function castExpectoPatronum() {
            const patronus = ['ğŸ¦Œ ç‰¡é¹¿', 'ğŸº å·¨ç‹¼', 'ğŸˆ çŒ«å’ª', 'ğŸ‰ ä¸œæ–¹ç¥é¾™'][Math.floor(Math.random() * 4)];
            const protectionMessage = `âœ¨ Expecto Patronum! æ‚¨çš„å®ˆæŠ¤ç¥ (${patronus}) å‡ºç°ï¼Œå®ƒæ•£å‘ç€æ¸©æš–çš„é“¶è‰²å…‰èŠ’ï¼Œé©±æ•£äº†æ‰€æœ‰çš„é»‘æš—å’Œ Bugã€‚`;
            writeOutput(protectionMessage, 'welcome');
        }


        // --- æ ¸å¿ƒå‘½ä»¤æ‰§è¡Œ (é›†æˆæ‰€æœ‰å‘½ä»¤) ---            
        const commands = {
            'help': { description: 'æ˜¾ç¤ºå¯ç”¨å‘½ä»¤åˆ—è¡¨ã€‚', execute: () => {
                let helpOutput = 'å¯ç”¨å‘½ä»¤ (æ€»è®¡ ' + Object.keys(commands).length + ' ä¸ª):\n';
                for (const cmd in commands) {
                    helpOutput += `  ${cmd.padEnd(12)} - ${commands[cmd].description}\n`;
                }
                writeOutput(helpOutput);
            }},
            'clear': { description: 'æ¸…ç©ºç»ˆç«¯å±å¹•ã€‚', execute: () => { output.innerHTML = ''; writeWelcome(); } },
            'ls': { description: 'åˆ—å‡ºå½“å‰ç›®å½•å†…å®¹ã€‚', execute: () => {
                const node = getCurrentDirNode();
                if (!node || node.type !== 'dir') { writeOutput(`é”™è¯¯: æ— æ³•è¯»å–ç›®å½• ${currentPath}`, 'error'); return; }                        
                const items = Object.values(node.contents).sort((a, b) => {
                    if (a.type === 'dir' && b.type === 'file') return -1;
                    if (a.type === 'file' && b.type === 'dir') return 1;
                    return a.name.localeCompare(b.name);
                });
                items.forEach(item => {
                    const typeClass = item.type === 'dir' ? 'dir' : 'file';
                    let name = item.type === 'dir' ? item.name + '/' : item.name;
                    if (item.locked) { name += ' (Locked)'; }
                    const span = document.createElement('span');
                    span.className = `output-item ${typeClass}`;
                    span.textContent = name;
                    output.appendChild(span);
                    output.innerHTML += '&nbsp;&nbsp;&nbsp;';
                });
                output.appendChild(document.createElement('br'));
                scrollToBottom();
            }},
            'cd': { description: 'åˆ‡æ¢ç›®å½•ã€‚ç”¨æ³•: cd <ç›®å½•å>', execute: (args) => {
                const target = args[0];
                if (!target) { currentPath = '/home/user'; updatePrompt(); return; }
                let newPath;
                if (target === '/') { newPath = '/'; }
                else if (target.startsWith('/')) { newPath = target; }
                else if (target === '..') {
                    if (currentPath === '/') return;
                    newPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                    if (newPath === '') newPath = '/';
                } else { newPath = currentPath === '/' ? `/${target}` : `${currentPath}/${target}`; }

                newPath = newPath.replace(/\/\/+/g, '/');
                const node = getDirNode(newPath);

                if (!node) { writeOutput(`cd: ç›®å½•ä¸å­˜åœ¨: ${target}`, 'error'); }
                else if (node.type !== 'dir') { writeOutput(`cd: ä¸æ˜¯ç›®å½•: ${target}`, 'error'); }
                else {
                    currentPath = newPath.endsWith('/') && newPath.length > 1 ? newPath.slice(0, -1) : newPath;
                    updatePrompt();
                }
            }},
            'fortune': { description: 'æ˜¾ç¤ºä¸€å¥éšæœºçš„ç®´è¨€æˆ–åè¨€ã€‚', execute: () => {
                const quote = fortunes[Math.floor(Math.random() * fortunes.length)];                        
                const line = '='.repeat(quote.length + 4);
                writeOutput(`\n${line}\n| ${quote} |\n${line}\n`);
            }},
            'echo': { description: 'åœ¨ç»ˆç«¯ä¸Šæ‰“å°æ–‡æœ¬ã€‚', execute: (args) => { writeOutput(args.join(' ')); } },
            'date': { description: 'æ˜¾ç¤ºå½“å‰æ—¥æœŸå’Œæ—¶é—´ã€‚', execute: () => { writeOutput(new Date().toLocaleString()); } },
            'whoami': { description: 'æ˜¾ç¤ºå½“å‰ç”¨æˆ·åã€‚', execute: () => { writeOutput(CLI_USER); } },
            'pwd': { description: 'æ‰“å°å½“å‰å·¥ä½œç›®å½•ã€‚', execute: () => { writeOutput(currentPath); } },
            'touch': { description: 'åœ¨å½“å‰ç›®å½•æˆ–æŒ‡å®šè·¯å¾„åˆ›å»ºç©ºæ–‡ä»¶ã€‚', execute: (args) => {
                if (args.length === 0) { writeOutput('touch: ç¼ºå°‘æ–‡ä»¶æ“ä½œæ•°ã€‚', 'error'); return; }
                const fileName = args[0];
                const currentNode = getCurrentDirNode();
                if (!currentNode.contents[fileName]) { currentNode.contents[fileName] = { name: fileName, type: 'file' }; }
            }},
            'mkdir': { description: 'åˆ›å»ºä¸€ä¸ªæ–°ç›®å½•ã€‚ç”¨æ³•: mkdir <ç›®å½•å>', execute: (args) => {
                if (args.length === 0) { writeOutput('mkdir: ç¼ºå°‘ç›®å½•åã€‚', 'error'); return; }
                const dirName = args[0];
                const currentNode = getCurrentDirNode();
                if (!currentNode.contents[dirName]) { currentNode.contents[dirName] = { name: dirName, type: 'dir', contents: {} }; }
            }},
            'rmdir': { description: 'åˆ é™¤ç©ºç›®å½•ã€‚ç”¨æ³•: rmdir <ç›®å½•å>', execute: (args) => {
                if (args.length === 0) { writeOutput('rmdir: ç¼ºå°‘æ“ä½œæ•°ã€‚', 'error'); return; }
                const dirName = args[0];
                const currentNode = getCurrentDirNode();
                const targetNode = currentNode.contents[dirName];
                if (!targetNode || targetNode.type !== 'dir') { writeOutput(`rmdir: æ— æ³•åˆ é™¤ â€˜${dirName}â€™: ä¸æ˜¯ç›®å½•æˆ–ä¸å­˜åœ¨`, 'error'); return; }
                if (Object.keys(targetNode.contents).length > 0) { writeOutput(`rmdir: æ— æ³•åˆ é™¤ â€˜${dirName}â€™: ç›®å½•éç©º`, 'error'); }
                else { delete currentNode.contents[dirName]; }
            }},
            'rm': { description: 'åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•(ä½¿ç”¨ -r é€’å½’åˆ é™¤)ã€‚ç”¨æ³•: rm [-r] <æ–‡ä»¶/ç›®å½•>', execute: (args) => {
                let recursive = false; let targetIndex = 0;
                if (args[0] === '-r') { recursive = true; targetIndex = 1; }
                const targetName = args[targetIndex];
                if (!targetName) { writeOutput('rm: ç¼ºå°‘æ“ä½œæ•°ã€‚', 'error'); return; }
                const currentNode = getCurrentDirNode();
                const targetNode = currentNode.contents[targetName];
                if (!targetNode) { writeOutput(`rm: æ— æ³•åˆ é™¤ â€˜${targetName}â€™: æ–‡ä»¶æˆ–ç›®å½•ä¸å­˜åœ¨`, 'error'); return; }
                if (targetNode.locked) { writeOutput(`rm: æƒé™è¢«æ‹’ç»: æ–‡ä»¶ â€˜${targetName}â€™ è¢«é­”æ³•é”å®šã€‚`, 'error'); return; }
                if (targetNode.type === 'dir' && !recursive) { writeOutput(`rm: æ— æ³•åˆ é™¤ â€˜${targetName}â€™: æ˜¯ç›®å½• (ä½¿ç”¨ -r é€’å½’åˆ é™¤)`, 'error'); return; }
                delete currentNode.contents[targetName]; writeOutput(`å·²åˆ é™¤ ${targetName}`);
            }},
            'linuxlogo': { description: 'æ˜¾ç¤º logo å’Œç³»ç»Ÿä¿¡æ¯ã€‚', execute: () => { writeOutput(`      /\\ /\\         OS: Web-CLI FunOS\n     ( â—• â—• )        Kernel: 5.15.0-js-web\n   <  / ^ \\  >      Uptime: ...\n    \\ \\_/ /       User: ${CLI_USER}\n     '---'        CPU: Browser Core (x86_64)`, 'welcome'); } },
            'ruler': { description: 'ç”Ÿæˆä¸€æ¡æŒ‡å®šé•¿åº¦çš„ ASCII å°ºã€‚ç”¨æ³•: ruler [é•¿åº¦]', execute: (args) => {
                const defaultLength = 80;
                let length = defaultLength;
                
                if (args.length > 0) {
                    const parsedLength = parseInt(args[0]);
                    if (!isNaN(parsedLength) && parsedLength > 0) {
                        length = Math.min(parsedLength, 120);
                    } else {
                        writeOutput('ruler: æ— æ•ˆçš„é•¿åº¦å‚æ•°ï¼Œä½¿ç”¨é»˜è®¤é•¿åº¦ 80ã€‚', 'error');
                    }
                }

                let indexLine = '';
                let scaleLine = '';
                let tempScale = 0;

                for (let i = 0; i < length; i++) {
                    if (i % 10 === 0) {
                        const numStr = String(tempScale);
                        if (i + numStr.length <= length) {
                            indexLine += numStr;
                            indexLine += ' '.repeat(10 - numStr.length);
                            i += (10 - 1); 
                            scaleLine += '|' + '-'.repeat(9);
                            tempScale += 10;
                        } else {
                            scaleLine += '|' + '-'.repeat(length - scaleLine.length - 1);
                            break;
                        }
                    } else if (i % 5 === 0) {
                        scaleLine += '+';
                        indexLine += ' ';
                    } else {
                        scaleLine += '-';
                        indexLine += ' ';
                    }
                }
                scaleLine = scaleLine.substring(0, length);
                indexLine = indexLine.substring(0, length);
                
                const rulerOutput = 
                    `å°ºå­é•¿åº¦: ${length} ä¸ªå­—ç¬¦ (è¯·ä½¿ç”¨å…¨å®½/ç­‰å®½å­—ä½“)\n` +
                    `<span style="color:#ff8000;">${indexLine}</span>\n` +
                    `<span style="color:#ff8000;">${scaleLine}</span>`;

                writeHtmlOutput(`<pre class="ruler-ascii">${rulerOutput}</pre>`);
            }}, 

            // --- ç½‘ç»œ/å·¥å…·æ¨¡æ‹Ÿå‘½ä»¤ ---
            'curl': { description: 'æ¨¡æ‹Ÿ HTTP GET è¯·æ±‚ã€‚ç”¨æ³•: curl <URL> (æ¨¡æ‹Ÿå»¶è¿Ÿ)', execute: (args) => {
                if (!args[0]) { writeOutput('curl: ç¼ºå°‘ URLã€‚', 'error'); return; }
                writeOutput(`% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n`);
                let progress = 0;
                const url = args[0].replace(/^(https?:\/\/)?/i, 'https://');
                
                const interval = setInterval(() => {
                    progress += Math.floor(Math.random() * 20) + 10;
                    if (progress >= 100) {
                        clearInterval(interval);
                        writeOutput(`100   283  100   283    0     0   400k      0 --:--:-- --:--:-- --:--:-- 400k\n`);
                        writeOutput(`<html><head><title>Simulated Response</title></head><body><h1>Success!</h1><p>Data from ${url} retrieved (simulated).</p></body></html>`);
                    } else {
                         writeOutput(`${progress.toString().padStart(3)}   283  ${progress.toString().padStart(3)}   ${Math.floor(283 * progress / 100).toString().padStart(4)}    0     0   400k      0 --:--:-- --:--:-- --:--:-- 400k`);
                    }
                    scrollToBottom();
                }, 200);
                activeIntervals.push(interval);
            }},
            'ping': { description: 'æµ‹è¯•ç½‘ç»œè¿æ¥ã€‚ç”¨æ³•: ping <IP/åŸŸå> (æ¨¡æ‹Ÿå»¶è¿Ÿ, Ctrl+C åœæ­¢)', execute: (args) => {
                 if (!args[0]) { writeOutput('ping: ç¼ºå°‘ç›®æ ‡ã€‚', 'error'); return; }
                 const target = args[0];
                 let sequence = 0;
                 writeOutput(`PING ${target} (192.168.${Math.floor(Math.random()*255)}.${Math.floor(Math.random()*255)}) 56(84) bytes of data.`);
                 
                 const intervalId = setInterval(() => {
                    sequence++;
                    const time = (Math.random() * 100 + 5).toFixed(2);
                    writeOutput(`64 bytes from ${target}: icmp_seq=${sequence} ttl=64 time=${time} ms`);
                 }, 1000);
                 activeIntervals.push(intervalId);
                 isCtrlCBlocked = true;
                 writeOutput("Ping æ¨¡æ‹Ÿè¿è¡Œä¸­... æŒ‰ Ctrl+C åœæ­¢ã€‚");
            }},
            'ncat': { description: 'æ¨¡æ‹Ÿç½‘ç»œè¿æ¥å’Œç«¯å£æ‰«æã€‚ç”¨æ³•: ncat -z <IP> <port>', execute: (args) => {
                if (args[0] === '-z' && args.length >= 3) {
                    const ip = args[1];
                    const port = parseInt(args[2]);
                    if (isNaN(port)) { writeOutput('ncat: æ— æ•ˆçš„ç«¯å£å·ã€‚', 'error'); return; }
                    
                    const status = (port % 2 === 0 || Math.random() > 0.6) ? 'open' : 'closed';
                    const delay = (Math.random() * 100 + 50).toFixed(2);

                    setTimeout(() => {
                        writeOutput(`Ncat: Version 7.93 (æ¨¡æ‹Ÿ)\nNcat: Connected to ${ip}:${port}.\nNcat: Port ${port} (${status}).\nNcat: Elapsed time: ${delay}ms.`);
                    }, Math.random() * 500 + 200);
                } else {
                    writeOutput('ncat: ç”¨æ³•: ncat -z <IP> <port>', 'error');
                }
            }},
            'display': { description: 'åœ¨ç»ˆç«¯ä¸­æ¨¡æ‹Ÿæ˜¾ç¤ºå›¾åƒã€‚ç”¨æ³•: display [URL]', execute: (args) => {
                const url = args[0] || 'https://picsum.photos/300/200';
                writeHtmlOutput(`æ¨¡æ‹Ÿå›¾åƒæ˜¾ç¤º: <img src="${url}" alt="æ¨¡æ‹Ÿå›¾åƒ" style="max-width:300px; height:auto;">`);
            }},
            'makemagnet': { description: 'æ¨¡æ‹Ÿå°†ä¸‹è½½é“¾æ¥/æ–‡ä»¶åè½¬æ¢ä¸ºç£åŠ›é“¾æ¥ã€‚ç”¨æ³•: makemagnet <æ–‡ä»¶å/URL>', execute: (args) => {
                if (!args[0]) { writeOutput('makemagnet: ç¼ºå°‘æ–‡ä»¶åæˆ– URLã€‚', 'error'); return; }
                const hash = Array.from({ length: 40 }, () => '0123456789abcdef'[Math.floor(Math.random() * 16)]).join('');
                writeOutput(`æ–‡ä»¶å: ${args[0].substring(0, 30)}...\n`);
                writeOutput(`æˆåŠŸè½¬æ¢: magnet:?xt=urn:btih:${hash}&dn=${encodeURIComponent(args[0].substring(0, 50))}\n`);
            }},
            'qrterminal': { description: 'å°†æ–‡æœ¬æˆ– URL ç¼–ç ä¸º ASCII äºŒç»´ç ã€‚ç”¨æ³•: qrterminal <TEXT/URL>', execute: (args) => {
                if (!args[0]) { writeOutput('qrterminal: ç¼ºå°‘è¦ç¼–ç çš„æ–‡æœ¬æˆ– URLã€‚', 'error'); return; }
                const asciiQr = qrCodeToAscii(args[0]);
                writeHtmlOutput(`<pre class="qr-code-ascii">${asciiQr}</pre>`);
                writeOutput(`å·²å°†å†…å®¹ç¼–ç ä¸º ASCII äºŒç»´ç : ${args[0].substring(0, 30)}...`);
            }},
            'pwgen': { description: 'ç”Ÿæˆéšæœºå¯†ç ã€‚ç”¨æ³•: pwgen <é•¿åº¦> [æ•°é‡] (é»˜è®¤é•¿åº¦16, æ•°é‡1)', execute: (args) => {
                let length = parseInt(args[0]) || 16;
                let count = parseInt(args[1]) || 1;
                length = Math.min(Math.max(length, 8), 64);
                count = Math.min(Math.max(count, 1), 10);
                
                let passwords = [];
                for (let i = 0; i < count; i++) {
                    passwords.push(generatePassword(length));
                }
                writeOutput(`ç”Ÿæˆçš„ ${count} ä¸ª ${length} ä½å¯†ç :\n${passwords.join('\n')}`, 'welcome');
            }},

            // --- é‡‘è/èŠå¤©/å åœå‘½ä»¤ ---
            'crypto': { description: 'æ˜¾ç¤ºä¸»æµåŠ å¯†è´§å¸çš„å®æ—¶ä»·æ ¼ (æ¨¡æ‹Ÿæ•°æ®)ã€‚ç”¨æ³•: crypto', execute: () => {
                let output = 'æ¨¡æ‹Ÿå®æ—¶åŠ å¯†è´§å¸ä»·æ ¼ (USD):\n';
                for (const [coin, price] of Object.entries(cryptoData)) {
                    const currentPrice = (price + (Math.random() * 10 - 5)).toFixed(2);
                    output += `${coin.padEnd(6)}: $${currentPrice.padStart(8)}\n`;
                }
                writeOutput(output);
            }},
            'stock': { description: 'æ˜¾ç¤ºæ¨¡æ‹Ÿçš„è‚¡ç¥¨å®æ—¶è¡Œæƒ…ã€‚ç”¨æ³•: stock <è‚¡ç¥¨ä»£ç > (é»˜è®¤: AAPL)', execute: (args) => {
                const code = (args[0] || 'AAPL').toUpperCase();
                const data = stockData[code] || stockData['AAPL'];
                const currentPrice = (data.price + (Math.random() * 2 - 1)).toFixed(2);
                const currentChange = (data.change + (Math.random() * 0.5 - 0.25)).toFixed(2);
                const sign = currentChange >= 0 ? '+' : '';
                writeOutput(`è‚¡ç¥¨ä»£ç : ${code}\nä»·æ ¼: $${currentPrice}\næ¶¨è·Œ: ${sign}${currentChange} (${data.sector} è¡Œä¸š)\n`);
            }},
            'fx': { description: 'æŸ¥è¯¢è´§å¸æ±‡ç‡æˆ–è¿›è¡Œè½¬æ¢ã€‚ç”¨æ³•: fx <FROM> <TO> [AMOUNT]', execute: (args) => {
                const from = args[0] ? args[0].toUpperCase() : 'USD';
                const to = args[1] ? args[1].toUpperCase() : 'EUR';
                const amount = parseFloat(args[2]) || 1;

                if (!fxRates[from] || !fxRates[from][to]) {
                    writeOutput(`fx: æ¨¡æ‹Ÿæ•°æ®åº“ä¸­æ‰¾ä¸åˆ° ${from} åˆ° ${to} çš„æ±‡ç‡ã€‚`, 'error');
                    return;
                }
                
                const rate = fxRates[from][to] + (Math.random() * 0.01 - 0.005);
                const result = (amount * rate).toFixed(4);
                writeOutput(`${amount} ${from} = ${result} ${to} (æ±‡ç‡: ${rate.toFixed(4)})`);
            }},
            'chat': { description: 'å¯åŠ¨AIèŠå¤©ä¼šè¯ã€‚è¾“å…¥ /quit æˆ– /exit é€€å‡ºä¼šè¯ã€‚', execute: () => {
                isChatMode = true;
                chatHistory = [];
                updatePrompt();
                writeOutput("ğŸ’¬ è¿›å…¥ AI èŠå¤©ä¼šè¯ã€‚è¾“å…¥æ‚¨çš„é—®é¢˜ï¼Œè¾“å…¥ '/quit' æˆ– '/exit' é€€å‡ºã€‚");
            }},
            'divine': { description: 'è¿›è¡Œå…­çˆ»å åœï¼Œæ¨¡æ‹Ÿå›ç­”æ‚¨æå‡ºçš„é—®é¢˜ã€‚ç”¨æ³•: divine "æˆ‘çš„äº‹ä¸šè¿å¦‚ä½•?"', execute: (args) => {
                const question = args.length > 0 ? args.join(' ') : "å‘½è¿ä¹‹é—®";
                writeOutput(`\nğŸ”® å¯åŠ¨æ˜“å­¦å åœæ¨¡æ‹Ÿ... æ‚¨çš„é—®é¢˜æ˜¯: ${question}`);
                const { hexagram, changingHexagram } = generateHexagram();
                const analysis = analyzeHexagram(hexagram);
                
                let resultOutput = `\n--- æœ¬å¦ (${analysis.hexagramName}) ---\n`;
                for (let i = 5; i >= 0; i--) {
                    const yaoValue = hexagram[i];
                    resultOutput += `${6 - i}: ${getYaoSymbol(yaoValue).padEnd(2)} (${yaoMap[yaoValue].name})\n`;
                }
                
                resultOutput += `\n--- å åœè§£è¯» ---\n`;
                resultOutput += analysis.oracleMessage;
                writeOutput(resultOutput, 'welcome');
            }},

            // --- åŠ¨ç”»/åª’ä½“å‘½ä»¤ ---
            'mplayer': { description: 'æ¨¡æ‹Ÿåª’ä½“æ’­æ”¾å™¨ã€‚ç”¨æ³•: mplayer <URL/æ–‡ä»¶> (Ctrl+C åœæ­¢)', execute: (args) => {
                if (!args[0]) { writeOutput('mplayer: ç¼ºå°‘ URL æˆ–æ–‡ä»¶ã€‚', 'error'); return; }
                startMplayer(args[0]);
            }},
            'listen': { description: 'å°è¯•æ’­æ”¾æŒ‡å®šçš„éŸ³ä¹ URLã€‚ç”¨æ³•: listen <URL>', execute: (args) => {
                if (!args[0]) { writeOutput('listen: ç¼ºå°‘ URLã€‚', 'error'); return; }
                writeOutput(`[Web-Audio] å°è¯•åŠ è½½å¹¶æ’­æ”¾: ${args[0]}...\nï¼ˆç”±äºæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œå¯èƒ½éœ€è¦ç”¨æˆ·æ‰‹åŠ¨äº¤äº’åæ‰èƒ½æ’­æ”¾ã€‚ï¼‰`);
                try {
                    const audio = new Audio(args[0]);
                    audio.play().catch(e => {
                        writeOutput(`listen: æ’­æ”¾å¤±è´¥ã€‚é”™è¯¯ä¿¡æ¯: ${e.message}`, 'error');
                    });
                } catch (e) {
                     writeOutput(`listen: å†…éƒ¨é”™è¯¯: ${e.message}`, 'error');
                }
            }},
            'cbonsai': { description: 'æ¨¡æ‹Ÿ cbonsai ç›†æ ½ç”Ÿé•¿åŠ¨ç”»ã€‚Ctrl+C é€€å‡ºã€‚', execute: () => {
                startCbonsai();
            }},
            'sl': { description: 'è¿è¡Œä¸€è¾† ASCII è’¸æ±½ç«è½¦ç©¿è¶Šç»ˆç«¯ã€‚Ctrl+C é€€å‡ºã€‚', execute: () => {
                startSl();
            }},
            'gifwrap': { description: 'æ¨¡æ‹Ÿåœ¨ç»ˆç«¯ä¸­æ’­æ”¾ ASCII åŠ¨ç”»ã€‚Ctrl+C é€€å‡ºã€‚', execute: () => {
                startGifwrap();
            }},
            'gkrellm': { description: 'æ¨¡æ‹Ÿ GKrellM ç³»ç»Ÿç›‘è§†å™¨ã€‚Ctrl+C é€€å‡ºã€‚', execute: () => {
                 startGkrellm();
            }},
            'xsnow': { description: 'æ¨¡æ‹Ÿç»ˆç«¯é™é›ªæ•ˆæœã€‚æŒ‰ Ctrl+C é€€å‡ºã€‚', execute: () => {
                startXsnow();
            }},
            
            // --- é­”æ³• CAST å‘½ä»¤ (æ–°å¢) ---
            'cast': {
                description: 'æ–½æ”¾é­”æ³•å’’è¯­ã€‚è¯•è¯• lumos, alohomora, expecto patronumã€‚',
                execute: (args) => {
                    const spell = args[0] ? args[0].toLowerCase() : '';
                    const spellArgs = args.slice(1);
                    
                    switch (spell) {
                        case 'lumos':
                            castLumos(spellArgs);
                            break;
                        case 'alohomora':
                            castAlohomora();
                            break;
                        case 'expecto':
                            if (spellArgs[0] && spellArgs[0].toLowerCase() === 'patronum') {
                                castExpectoPatronum();
                            } else {
                                writeOutput(`cast: æœªçŸ¥æˆ–ä¸å®Œæ•´çš„å’’è¯­: ${args.join(' ')}ã€‚å®Œæ•´å’’è¯­: expecto patronumã€‚`, 'error');
                            }
                            break;
                        case 'nox':
                            castLumos(['nox']);
                            break;
                        default:
                            writeOutput(`cast: æœªçŸ¥å’’è¯­ '${spell}'ã€‚è¯•è¯• 'lumos', 'alohomora', 'expecto patronum'ã€‚`, 'error');
                            break;
                    }
                }
            }
        };

        // --- äº‹ä»¶å¤„ç†å’Œä¸»å¾ªç¯ ---
        
        function handleCommand() {
            let commandLine = input.value.trim();
            input.value = '';

            if (commandLine === '') return;

            writeCommandHistory(commandLine);
            history.unshift(commandLine);
            historyIndex = -1; 

            if (isChatMode) {
                if (commandLine.toLowerCase() === '/quit' || commandLine.toLowerCase() === '/exit') {
                    isChatMode = false;
                    updatePrompt();
                    writeOutput("ğŸ’¬ é€€å‡º AI èŠå¤©ä¼šè¯ã€‚");
                    return;
                }
                
                chatHistory.push({ role: 'user', content: commandLine });
                const aiResponse = simulateAiResponse(commandLine);
                chatHistory.push({ role: 'ai', content: aiResponse });
                writeOutput(`[AI Response]: ${aiResponse}`);
                scrollToBottom();
                return;
            }

            const parts = commandLine.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
            const command = parts[0];
            const args = parts.slice(1).map(arg => arg.replace(/"/g, ''));
            
            const cmd = command.toLowerCase();

            if (commands[cmd]) {
                commands[cmd].execute(args);
            } else {
                if (cmd.length > 2) {
                    const aiResponse = simulateAiResponse(commandLine);
                    writeOutput(`[AI Response]: ${aiResponse}`);
                } else {
                    writeOutput(`-web-cli: ${command}: command not found. è¯•è¯• 'help'ã€‚`, 'error');
                }
            }
            scrollToBottom();
        }

        function writeWelcome() {
            writeOutput("", '');
            writeOutput("", '');
            writeOutput("", ''); 
            writeOutput("");
        }

        input.addEventListener('keydown', function(event) {
            // Ctrl+C (Key 67)
            if ((event.ctrlKey && event.key.toLowerCase() === 'c')) {
                event.preventDefault(); 
                handleCtrlC();
            } else if (event.key === 'Enter') {
                handleCommand();
            } else if (event.key === 'Tab') {
                event.preventDefault();
                // è‡ªåŠ¨è¡¥å…¨é€»è¾‘å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (history.length > 0) {
                    historyIndex = Math.min(historyIndex + 1, history.length - 1);
                    input.value = history[historyIndex];
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = history[historyIndex];
                } else {
                    historyIndex = -1;
                    input.value = '';
                }
            }
        });
        
        // åˆå§‹åŒ–
        writeWelcome();
        updatePrompt();
        
    </script>
</body>
</html>
