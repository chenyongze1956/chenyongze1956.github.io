
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selfie Camera</title>
    <!-- Tailwind CSS v3 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {

                         background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);

                    colors: {
                        primary: '#ff7e5f',
                        secondary: '#feb47b',
                        dark: '#ffed86',
                        light: '#5fbfff'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    },
                    animation: {
                        'pulse-light': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .filter-none {
                filter: none;
            }
            .filter-black-white {
                filter: grayscale(100%);
            }
            .filter-sepia {
                filter: sepia(100%);
            }
            .filter-vintage {
                filter: sepia(60%) saturate(120%) contrast(80%);
            }
            .filter-cool {
                filter: hue-rotate(180deg) saturate(70%);
            }
            .filter-warm {
                filter: hue-rotate(30deg) saturate(120%);
            }
            .filter-dramatic {
                filter: contrast(150%) saturate(120%);
            }
            .filter-blur {
                filter: blur(2px);
            }
            .camera-shutter {
                animation: shutter 0.5s ease-in-out;
            }
            @keyframes shutter {
                0% { opacity: 1; }
                50% { opacity: 0; }
                100% { opacity: 1; }
            }
            .filter-preview {
                transition: all 0.3s ease;
            }
            .filter-preview:hover, .filter-preview.active {
                transform: scale(1.1);
                border-color: #3B82F6;
            }
            .camera-container {
                aspect-ratio: 9/16;
                max-height: 100vh;
            }
            @media (min-aspect-ratio: 9/16) {
                .camera-container {
                    aspect-ratio: 9/16;
                    max-width: 100vw;
                }
            }
        }
    </style>
</head>
<body class="bg-black text-white min-h-screen flex flex-col items-center justify-center p-4">
    <!-- Camera Container -->
    <div class="camera-container relative w-full max-w-md mx-auto rounded-xl overflow-hidden bg-dark shadow-2xl">
        <!-- Camera Preview -->
        <div id="camera-preview" class="absolute inset-0 z-0">
            <video id="video" class="w-full h-full object-cover" autoplay muted playsinline></video>
            <div id="filter-overlay" class="absolute inset-0 filter-none"></div>
            <div id="shutter-effect" class="absolute inset-0 bg-white opacity-0 z-10"></div>
        </div>

        <!-- Top Controls -->
        <div class="absolute top-0 left-0 right-0 z-20 flex justify-between items-center p-4">
            <button id="toggle-camera" class="bg-black bg-opacity-50 p-2 rounded-full hover:bg-opacity-70 transition-all">
                <i class="fa fa-refresh text-xl"></i>
            </button>
            <button id="toggle-flash" class="bg-black bg-opacity-50 p-2 rounded-full hover:bg-opacity-70 transition-all">
                <i class="fa fa-lightbulb-o text-xl"></i>
            </button>
        </div>

        <!-- Capture Button -->
        <div class="absolute bottom-24 left-0 right-0 z-20 flex justify-center">
            <button id="capture-btn" class="w-14 h-14 rounded-full bg-white border-3 border-gray-300 flex items-center justify-center hover:bg-gray-100 transition-all">
                <div class="w-11 h-11 rounded-full bg-gray-800"></div>
            </button>
        </div>

      

    <!-- Preview Modal -->
    <div id="preview-modal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="w-full max-w-md mx-auto p-4">
            <div class="relative">
                <button id="close-preview" class="absolute top-2 right-2 bg-black bg-opacity-50 p-2 rounded-full hover:bg-opacity-70 transition-all z-10">
                    <i class="fa fa-times text-xl"></i>
                </button>
                <img id="preview-image" class="w-full rounded-lg" alt="Preview">
                <div class="mt-4 flex justify-between">
                    <button id="save-image" class="bg-green-600 px-4 py-2 rounded-lg hover:bg-green-700 transition-all">
                        <i class="fa fa-download mr-2"></i> Save
                    </button>
                    <button id="share-image" class="bg-blue-600 px-4 py-2 rounded-lg hover:bg-blue-700 transition-all">
                        <i class="fa fa-share-alt mr-2"></i> Share
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div id="error-modal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="w-full max-w-md mx-auto p-4 bg-dark rounded-lg">
            <h2 class="text-xl font-bold mb-4 text-red-500"><i class="fa fa-exclamation-triangle mr-2"></i> Error</h2>
            <p id="error-message" class="mb-4"></p>
            <button id="close-error" class="w-full bg-red-600 px-4 py-2 rounded-lg hover:bg-red-700 transition-all">
                Close
            </button>
        </div>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById('video');
        const filterOverlay = document.getElementById('filter-overlay');
        const shutterEffect = document.getElementById('shutter-effect');
        const captureBtn = document.getElementById('capture-btn');
        const toggleCameraBtn = document.getElementById('toggle-camera');
        const toggleFlashBtn = document.getElementById('toggle-flash');
        const filterPreviews = document.querySelectorAll('.filter-preview');
        const previewModal = document.getElementById('preview-modal');
        const previewImage = document.getElementById('preview-image');
        const closePreviewBtn = document.getElementById('close-preview');
        const saveImageBtn = document.getElementById('save-image');
        const shareImageBtn = document.getElementById('share-image');
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const closeErrorBtn = document.getElementById('close-error');

        // Variables
        let currentFilter = 'none';
        let currentStream = null;
        let currentCamera = 'user'; // 'user' for front camera, 'environment' for back camera
        let hasFlash = false;
        let flashOn = false;

        // Initialize the camera
        async function initCamera() {
            try {
                // Request camera permission
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: currentCamera },
                    audio: false
                });

                // Display the video stream
                video.srcObject = currentStream;

                // Check if flash is available
                const tracks = currentStream.getVideoTracks();
                if (tracks.length > 0) {
                    const capabilities = tracks[0].getCapabilities();
                    hasFlash = capabilities.torch && capabilities.torch.supported;
                    
                    // Update flash button visibility
                    toggleFlashBtn.style.display = hasFlash ? 'block' : 'none';
                }
            } catch (error) {
                console.error('Error accessing camera:', error);
                showError('Could not access the camera. Please make sure you have granted camera permissions.');
            }
        }

        // Capture a photo
        function capturePhoto() {
            // Create a canvas element
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw the current video frame to the canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Apply the current filter to the canvas
            applyFilterToCanvas(canvas, currentFilter);

            // Convert canvas to image data URL
            const imageDataUrl = canvas.toDataURL('image/png');

            // Show preview
            showPreview(imageDataUrl);
        }

        // Apply filter to canvas
        function applyFilterToCanvas(canvas, filter) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            switch (filter) {
                case 'black-white':
                    // Grayscale
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg;     // Red
                        data[i + 1] = avg; // Green
                        data[i + 2] = avg; // Blue
                    }
                    break;
                case 'sepia':
                    // Sepia
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                    }
                    break;
                case 'vintage':
                    // Vintage effect
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        data[i] = Math.min(255, (r * 0.627) + (g * 0.320) + (b * 0.157));
                        data[i + 1] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        data[i + 2] = Math.min(255, (r * 0.027) + (g * 0.182) + (b * 0.437));
                    }
                    break;
                case 'cool':
                    // Cool effect (increase blue, decrease red)
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, data[i] - 30);     // Red
                        data[i + 2] = Math.min(255, data[i + 2] + 30); // Blue
                    }
                    break;
                case 'warm':
                    // Warm effect (increase red and green, decrease blue)
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] + 30);     // Red
                        data[i + 1] = Math.min(255, data[i + 1] + 15); // Green
                        data[i + 2] = Math.max(0, data[i + 2] - 30); // Blue
                    }
                    break;
                case 'dramatic':
                    // Dramatic effect (increase contrast)
                    const factor = 259 * (100 + 128) / (255 * (259 - 128));
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));     // Red
                        data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128)); // Green
                        data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128)); // Blue
                    }
                    break;
                case 'blur':
                    // Simple blur effect (box blur)
                    const copy = new Uint8ClampedArray(data);
                    const kernelSize = 3;
                    const kernelHalf = Math.floor(kernelSize / 2);
                    
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            let r = 0, g = 0, b = 0;
                            let count = 0;
                            
                            for (let ky = -kernelHalf; ky <= kernelHalf; ky++) {
                                for (let kx = -kernelHalf; kx <= kernelHalf; kx++) {
                                    const pixelX = Math.min(canvas.width - 1, Math.max(0, x + kx));
                                    const pixelY = Math.min(canvas.height - 1, Math.max(0, y + ky));
                                    const pixelIndex = (pixelY * canvas.width + pixelX) * 4;
                                    
                                    r += copy[pixelIndex];
                                    g += copy[pixelIndex + 1];
                                    b += copy[pixelIndex + 2];
                                    count++;
                                }
                            }
                            
                            const pixelIndex = (y * canvas.width + x) * 4;
                            data[pixelIndex] = r / count;
                            data[pixelIndex + 1] = g / count;
                            data[pixelIndex + 2] = b / count;
                        }
                    }
                    break;
                // 'none' filter does nothing
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Show preview of the captured photo
        function showPreview(imageDataUrl) {
            previewImage.src = imageDataUrl;
            previewModal.classList.remove('hidden');
        }

        // Save the captured photo to the device
        function saveImage() {
            const link = document.createElement('a');
            link.href = previewImage.src;
            link.download = `selfie-${new Date().toISOString().slice(0, 10)}.png`;
            link.click();
        }

        // Share the captured photo
        function shareImage() {
            if (!navigator.share) {
                showError('Sharing is not supported on this device.');
                return;
            }

            // Create a file from the data URL
            fetch(previewImage.src)
                .then(response => response.blob())
                .then(blob => {
                    const file = new File([blob], `selfie-${new Date().toISOString().slice(0, 10)}.png`, { type: 'image/png' });
                    const filesArray = [file];
                    
                    // Share the file
                    navigator.share({
                        title: 'My Selfie',
                        text: 'Check out my selfie!',
                        files: filesArray
                    })
                    .catch(error => {
                        console.error('Error sharing:', error);
                        showError('Failed to share the image.');
                    });
                })
                .catch(error => {
                    console.error('Error creating file:', error);
                    showError('Failed to prepare image for sharing.');
                });
        }

        // Toggle between front and back cameras
        async function toggleCamera() {
            try {
                // Stop the current stream
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                // Switch camera
                currentCamera = currentCamera === 'user' ? 'environment' : 'user';

                // Start the new stream
                await initCamera();
            } catch (error) {
                console.error('Error switching camera:', error);
                showError('Could not switch cameras. Please try again.');
            }
        }

        // Toggle flash/torch
        async function toggleFlash() {
            if (!hasFlash) return;

            try {
                const tracks = currentStream.getVideoTracks();
                if (tracks.length > 0) {
                    flashOn = !flashOn;
                    await tracks[0].applyConstraints({
                        advanced: [{ torch: flashOn }]
                    });

                    // Update flash button icon
                    const icon = toggleFlashBtn.querySelector('i');
                    if (flashOn) {
                        icon.classList.remove('fa-lightbulb-o');
                        icon.classList.add('fa-sun-o');
                    } else {
                        icon.classList.remove('fa-sun-o');
                        icon.classList.add('fa-lightbulb-o');
                    }
                }
            } catch (error) {
                console.error('Error toggling flash:', error);
                showError('Could not toggle flash. Please try again.');
            }
        }

        // Show error message
        function showError(message) {
            errorMessage.textContent = message;
            errorModal.classList.remove('hidden');
        }

        // Event Listeners
        captureBtn.addEventListener('click', () => {
            // Trigger shutter effect
            shutterEffect.classList.add('camera-shutter');
            
            // Capture photo after the shutter effect
            setTimeout(() => {
                capturePhoto();
                shutterEffect.classList.remove('camera-shutter');
            }, 250);
        });

        toggleCameraBtn.addEventListener('click', toggleCamera);
        toggleFlashBtn.addEventListener('click', toggleFlash);

        // Filter selection
        filterPreviews.forEach(preview => {
            preview.addEventListener('click', () => {
                // Remove active class from all previews
                filterPreviews.forEach(p => p.classList.remove('active'));
                
                // Add active class to clicked preview
                preview.classList.add('active');
                
                // Get the selected filter
                currentFilter = preview.dataset.filter;
                
                // Apply the filter to the overlay
                filterOverlay.className = `absolute inset-0 filter-${currentFilter}`;
            });
        });

        // Preview modal
        closePreviewBtn.addEventListener('click', () => {
            previewModal.classList.add('hidden');
        });

        saveImageBtn.addEventListener('click', saveImage);
        shareImageBtn.addEventListener('click', shareImage);

        // Error modal
        closeErrorBtn.addEventListener('click', () => {
            errorModal.classList.add('hidden');
        });

        // Initialize the camera when the page loads
        window.addEventListener('load', initCamera);
    </script>
</body>
</html>

<style>

#shutter-effect{

     background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);

    
}


    #capture-btn{

     background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
        
    }
    </style>
