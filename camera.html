
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Selfie Camera</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        // Tailwind CSS configuration
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6', // Blue for active states
                        secondary: '#60A5FA',
                        darkBg: '#1f2937', // Darker background
                        lightBg: '#374151'  // Lighter background elements
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        /* Custom Tailwind Utilities for Filters */
        @layer utilities {
            .filter-none { filter: none; }
            .filter-black-white { filter: grayscale(100%); }
            .filter-sepia { filter: sepia(100%); }
            .filter-vintage { filter: sepia(60%) saturate(120%) contrast(80%); }
            .filter-cool { filter: hue-rotate(180deg) saturate(70%); }
            .filter-warm { filter: hue-rotate(30deg) saturate(120%); }
            .filter-dramatic { filter: contrast(150%) saturate(120%); }
            .filter-blur { filter: blur(2px); }
            .filter-cartoon { filter: saturate(180%) contrast(150%); } /* Placeholder for CSS */
            .filter-pixelate { filter: contrast(120%); } /* Placeholder for CSS */
            .filter-invert { filter: invert(100%); }

            /* Camera specific styles */
            .camera-container {
                aspect-ratio: 9/16; /* Standard phone aspect ratio */
                max-height: 90vh; /* Max height to fit viewport */
                width: 100%;
                max-width: 420px; /* Max width for phone-like feel */
            }

            /* Shutter animation for flash effect */
            .shutter-effect {
                animation: shutter 0.2s ease-out;
            }
            @keyframes shutter {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }

            /* Filter preview active state */
            .filter-preview-item {
                transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out;
            }
            .filter-preview-item:hover, .filter-preview-item.active {
                transform: scale(1.05);
                border-color: theme('colors.primary');
            }
        }
    </style>
</head>
<body class="bg-darkBg text-white min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="camera-container relative mx-auto rounded-2xl overflow-hidden shadow-2xl bg-lightBg flex flex-col">

        <div id="camera-preview-area" class="relative flex-grow bg-black">
            <video id="video" class="w-full h-full object-cover transform scale-x-[-1]" autoplay muted playsinline></video>
            <div id="filter-overlay" class="absolute inset-0 filter-none pointer-events-none"></div>
            <div id="shutter-flash" class="absolute inset-0 bg-white opacity-0 pointer-events-none"></div>
        </div>

        <div class="absolute top-0 left-0 right-0 z-10 flex justify-between items-center p-4">
            <button id="toggle-camera" class="bg-black bg-opacity-40 p-2 rounded-full hover:bg-opacity-60 transition-all text-white">
                <i class="fa fa-refresh text-xl"></i>
            </button>
            <button id="toggle-flash" class="bg-black bg-opacity-40 p-2 rounded-full hover:bg-opacity-60 transition-all text-white hidden">
                <i class="fa fa-lightbulb-o text-xl"></i>
            </button>
        </div>

       

        <div id="kk" class="z-20 py-4 bg-darkBg flex justify-center items-center">
            <button id="capture-btn" class="w-16 h-16 rounded-full bg-white border-4 border-gray-400 flex items-center justify-center shadow-lg hover:border-primary transition-all">
                <div class="w-11 h-11 rounded-full bg-gray-800"></div>
            </button>
        </div>

    </div>

    <div id="preview-modal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden p-4">
        <div id="kkk" class="w-full max-w-md bg-darkBg rounded-lg p-4 shadow-xl relative">
            <h2 class="text-xl font-bold mb-4 text-center">Captured Photo</h2>
            <button id="close-preview" class="absolute top-2 right-2 bg-gray-700 bg-opacity-70 p-2 rounded-full text-white hover:bg-opacity-100 transition-all">
                <i class="fa fa-times text-lg"></i>
            </button>
            <img id="preview-image" class="w-full rounded-lg mb-4 border border-gray-700" alt="Captured Photo">
            <div class="flex justify-around space-x-3">
                <button id="save-image" class="flex-1 bg-primary text-white py-3 rounded-lg hover:bg-blue-600 transition-all flex items-center justify-center text-lg">
                    <i class="fa fa-download mr-2"></i> Save
                </button>
                <button id="share-image" class="flex-1 bg-secondary text-white py-3 rounded-lg hover:bg-blue-500 transition-all flex items-center justify-center text-lg">
                    <i class="fa fa-share-alt mr-2"></i> Share
                </button>
            </div>
        </div>
    </div>

    <div id="error-modal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden p-4">
        <div class="w-full max-w-sm bg-red-800 rounded-lg p-6 text-white text-center shadow-xl">
            <h2 class="text-2xl font-bold mb-4"><i class="fa fa-exclamation-triangle mr-2"></i> Error!</h2>
            <p id="error-message" class="mb-6 text-lg"></p>
            <button id="close-error" class="w-full bg-red-600 py-3 rounded-lg hover:bg-red-700 transition-all text-xl">
                OK
            </button>
        </div>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById('video');
        const filterOverlay = document.getElementById('filter-overlay');
        const shutterFlash = document.getElementById('shutter-flash');
        const captureBtn = document.getElementById('capture-btn');
        const toggleCameraBtn = document.getElementById('toggle-camera');
        const toggleFlashBtn = document.getElementById('toggle-flash');
        const filterList = document.getElementById('filter-list');

        const previewModal = document.getElementById('preview-modal');
        const previewImage = document.getElementById('preview-image');
        const closePreviewBtn = document.getElementById('close-preview');
        const saveImageBtn = document.getElementById('save-image');
        const shareImageBtn = document.getElementById('share-image');

        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const closeErrorBtn = document.getElementById('close-error');

        // Global Variables
        let currentFilter = 'none'; // Default filter
        let currentStream = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let hasFlash = false;
        let flashOn = false;

        // Define available filters
        const filters = [
            { name: 'None', className: 'filter-none', jsFunction: null },
            { name: 'B&W', className: 'filter-black-white', jsFunction: applyBlackAndWhite },
            { name: 'Sepia', className: 'filter-sepia', jsFunction: applySepia },
            { name: 'Vintage', className: 'filter-vintage', jsFunction: applyVintage },
            { name: 'Cool', className: 'filter-cool', jsFunction: applyCool },
            { name: 'Warm', className: 'filter-warm', jsFunction: applyWarm },
            { name: 'Dramatic', className: 'filter-dramatic', jsFunction: applyDramatic },
            { name: 'Blur', className: 'filter-blur', jsFunction: applyBlur },
            { name: 'Cartoon', className: 'filter-cartoon', jsFunction: applyCartoon },
            { name: 'Pixelate', className: 'filter-pixelate', jsFunction: applyPixelate },
            { name: 'Invert', className: 'filter-invert', jsFunction: applyInvert },
        ];

        // --- Camera Initialization & Control ---

        async function initCamera() {
            try {
                // Stop any existing stream
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                // Request new stream with specified facingMode
                currentStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: currentFacingMode,
                        // Optional: constrain resolution for better performance
                        // width: { ideal: 1280 },
                        // height: { ideal: 720 }
                    },
                    audio: false
                });

                video.srcObject = currentStream;

                // Check for flash (torch) capability
                const videoTrack = currentStream.getVideoTracks()[0];
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    hasFlash = capabilities.torch; // true/false
                    toggleFlashBtn.style.display = hasFlash ? 'block' : 'none';
                }

                // Apply initial filter if any
                updateFilterOverlay();
                
                // Adjust video transform for front camera to not be mirrored in preview
                // Capture will handle mirroring separately
                if (currentFacingMode === 'user') {
                    video.style.transform = 'scaleX(-1)'; // Flip horizontally for selfie view
                } else {
                    video.style.transform = 'scaleX(1)'; // Normal for back camera
                }

            } catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showError('Camera access denied. Please allow camera permissions.');
                } else if (error.name === 'NotFoundError') {
                    showError('No camera found on this device.');
                } else {
                    showError('Could not start camera: ' + error.message);
                }
            }
        }

        function toggleCameraFacingMode() {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            flashOn = false; // Reset flash when camera switches
            toggleFlashBtn.querySelector('i').className = 'fa fa-lightbulb-o text-xl'; // Reset flash icon
            initCamera();
        }

        async function toggleFlashlight() {
            if (!hasFlash) return;

            try {
                const videoTrack = currentStream.getVideoTracks()[0];
                if (videoTrack) {
                    flashOn = !flashOn;
                    await videoTrack.applyConstraints({
                        advanced: [{ torch: flashOn }]
                    });
                    toggleFlashBtn.querySelector('i').className = flashOn ? 'fa fa-sun-o text-xl' : 'fa fa-lightbulb-o text-xl';
                }
            } catch (error) {
                console.error('Error toggling flash:', error);
                showError('Could not toggle flashlight.');
            }
        }

        // --- Filter Management ---

        function updateFilterOverlay() {
            const selectedFilter = filters.find(f => f.name.toLowerCase() === currentFilter.toLowerCase());
            filterOverlay.className = `absolute inset-0 pointer-events-none ${selectedFilter ? selectedFilter.className : 'filter-none'}`;
        }

        function createFilterPreviews() {
            filterList.innerHTML = ''; // Clear existing
            filters.forEach(filter => {
                const isActive = (filter.name.toLowerCase() === currentFilter.toLowerCase());
                const div = document.createElement('div');
                div.className = `flex-shrink-0 text-center cursor-pointer filter-preview-item p-1 ${isActive ? 'active' : ''}`;
                div.dataset.filter = filter.name.toLowerCase();

                const previewDiv = document.createElement('div');
                previewDiv.className = `w-16 h-16 rounded-lg border-2 ${isActive ? 'border-primary' : 'border-gray-700'} bg-gray-700 flex items-center justify-center text-sm overflow-hidden`;
                previewDiv.innerHTML = filter.name === 'None' ? 'None' : `<div class="w-full h-full ${filter.className}"></div>`; // Apply CSS filter for preview

                const nameP = document.createElement('p');
                nameP.className = 'text-xs mt-1 text-gray-300';
                nameP.textContent = filter.name;

                div.appendChild(previewDiv);
                div.appendChild(nameP);
                filterList.appendChild(div);

                div.addEventListener('click', () => {
                    currentFilter = filter.name.toLowerCase();
                    updateFilterOverlay(); // Update live preview
                    
                    // Update active state in UI
                    document.querySelectorAll('.filter-preview-item').forEach(item => {
                        item.classList.remove('active');
                        item.querySelector('div').classList.remove('border-primary');
                        item.querySelector('div').classList.add('border-gray-700');
                    });
                    div.classList.add('active');
                    previewDiv.classList.remove('border-gray-700');
                    previewDiv.classList.add('border-primary');
                });
            });
        }

        // --- Image Capture & Processing ---

        function capturePhoto() {
            shutterFlash.classList.add('shutter-effect'); // Trigger flash animation

            setTimeout(() => {
                shutterFlash.classList.remove('shutter-effect');

                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');

                // Mirror front camera image for capture
                if (currentFacingMode === 'user') {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Reset transform for filter application
                if (currentFacingMode === 'user') {
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                // Apply pixel-level JS filter
                const selectedFilter = filters.find(f => f.name.toLowerCase() === currentFilter.toLowerCase());
                if (selectedFilter && selectedFilter.jsFunction) {
                    selectedFilter.jsFunction(ctx, canvas.width, canvas.height);
                }

                const imageDataUrl = canvas.toDataURL('image/png');
                showPreview(imageDataUrl);

            }, 200); // Shutter animation duration
        }

        // --- Pixel-level Filter Functions (JavaScript) ---
        // These functions modify pixel data directly on the canvas context

        function applyBlackAndWhite(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114); // Luminosity method
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applySepia(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                data[i]     = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyVintage(ctx, width, height) {
            // Combines sepia-like tones with slight color shift and fade
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                // Apply a reddish/brownish tint and lower contrast
                data[i]     = Math.min(255, Math.max(0, r * 0.8 + g * 0.1 + b * 0.1 + 20));
                data[i + 1] = Math.min(255, Math.max(0, r * 0.1 + g * 0.7 + b * 0.2 + 10));
                data[i + 2] = Math.min(255, Math.max(0, r * 0.1 + g * 0.1 + b * 0.8 - 10));
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyCool(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, data[i] - 30);     // Decrease Red
                data[i + 2] = Math.min(255, data[i + 2] + 40); // Increase Blue
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyWarm(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] + 40);     // Increase Red
                data[i + 1] = Math.min(255, data[i + 1] + 15); // Slightly increase Green
                data[i + 2] = Math.max(0, data[i + 2] - 30); // Decrease Blue
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyDramatic(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const contrast = 1.8; // Higher contrast factor
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                data[i + 1] = Math.min(255, Math.max(0, factor * (data[i + 1] - 128) + 128));
                data[i + 2] = Math.min(255, Math.max(0, factor * (data[i + 2] - 128) + 128));
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        function applyBlur(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const copy = new Uint8ClampedArray(data); // Create a copy for reading pixel values
            const kernelSize = 3; // 3x3 blur kernel
            const kernelHalf = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    let count = 0;

                    for (let ky = -kernelHalf; ky <= kernelHalf; ky++) {
                        for (let kx = -kernelHalf; kx <= kernelHalf; kx++) {
                            const pixelX = Math.min(width - 1, Math.max(0, x + kx));
                            const pixelY = Math.min(height - 1, Math.max(0, y + ky));
                            const pixelIndex = (pixelY * width + pixelX) * 4;

                            r += copy[pixelIndex];
                            g += copy[pixelIndex + 1];
                            b += copy[pixelIndex + 2];
                            count++;
                        }
                    }

                    const currentPixelIndex = (y * width + x) * 4;
                    data[currentPixelIndex] = r / count;
                    data[currentPixelIndex + 1] = g / count;
                    data[currentPixelIndex + 2] = b / count;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyCartoon(ctx, width, height) {
            // Simplified cartoon: apply grayscale, then find edges and quantize colors
            // This is a basic approximation, full cartooning is complex
            applyBlackAndWhite(ctx, width, height); // Start with grayscale for edges
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const edgeThreshold = 30; // Threshold to detect edges

            // Quantize colors (simple posterization) and draw edges
            for (let i = 0; i < data.length; i += 4) {
                // Color quantization (reduce color palette)
                data[i] = Math.floor(data[i] / 64) * 64;
                data[i + 1] = Math.floor(data[i + 1] / 64) * 64;
                data[i + 2] = Math.floor(data[i + 2] / 64) * 64;

                // Simple edge detection (e.g., comparing with right neighbor)
                if (i % (width * 4) < (width * 4) - 4) { // Not the last pixel in row
                    const diffR = Math.abs(data[i] - data[i + 4]);
                    const diffG = Math.abs(data[i + 1] - data[i + 5]);
                    const diffB = Math.abs(data[i + 2] - data[i + 6]);

                    if (diffR > edgeThreshold || diffG > edgeThreshold || diffB > edgeThreshold) {
                        data[i] = 0; data[i + 1] = 0; data[i + 2] = 0; // Black edge
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        function applyPixelate(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const pixelSize = 8; // Size of each "pixel" block

            for (let y = 0; y < height; y += pixelSize) {
                for (let x = 0; x < width; x += pixelSize) {
                    let r = 0, g = 0, b = 0, count = 0;

                    // Calculate average color for the block
                    for (let sy = 0; sy < pixelSize && y + sy < height; sy++) {
                        for (let sx = 0; sx < pixelSize && x + sx < width; sx++) {
                            const pIndex = ((y + sy) * width + (x + sx)) * 4;
                            r += data[pIndex];
                            g += data[pIndex + 1];
                            b += data[pIndex + 2];
                            count++;
                        }
                    }
                    
                    if (count === 0) continue; // Avoid division by zero

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    // Fill the block with the average color
                    for (let sy = 0; sy < pixelSize && y + sy < height; sy++) {
                        for (let sx = 0; sx < pixelSize && x + sx < width; sx++) {
                            const pIndex = ((y + sy) * width + (x + sx)) * 4;
                            data[pIndex] = r;
                            data[pIndex + 1] = g;
                            data[pIndex + 2] = b;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyInvert(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];     // Invert Red
                data[i + 1] = 255 - data[i + 1]; // Invert Green
                data[i + 2] = 255 - data[i + 2]; // Invert Blue
            }
            ctx.putImageData(imageData, 0, 0);
        }


        // --- Modals & Utilities ---

        function showPreview(imageDataUrl) {
            previewImage.src = imageDataUrl;
            previewModal.classList.remove('hidden');
        }

        function saveImage() {
            const link = document.createElement('a');
            link.href = previewImage.src;
            link.download = `selfie-${currentFilter}-${new Date().toISOString().slice(0, 10)}.png`;
            link.click();
        }

        async function shareImage() {
            if (!navigator.share) {
                showError('Sharing is not supported on this browser/device.');
                return;
            }
            try {
                const blob = await fetch(previewImage.src).then(res => res.blob());
                const file = new File([blob], `selfie-${currentFilter}.png`, { type: 'image/png' });
                await navigator.share({
                    title: 'My Awesome Selfie',
                    text: `Check out my selfie with the ${currentFilter} filter!`,
                    files: [file]
                });
            } catch (error) {
                console.error('Error sharing:', error);
                showError('Failed to share the image. ' + error.message);
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorModal.classList.remove('hidden');
        }

        // --- Event Listeners ---

        document.addEventListener('DOMContentLoaded', () => {
            initCamera();
            createFilterPreviews();
        });

        captureBtn.addEventListener('click', capturePhoto);
        toggleCameraBtn.addEventListener('click', toggleCameraFacingMode);
        toggleFlashBtn.addEventListener('click', toggleFlashlight);

        closePreviewBtn.addEventListener('click', () => previewModal.classList.add('hidden'));
        saveImageBtn.addEventListener('click', saveImage);
        shareImageBtn.addEventListener('click', shareImage);

        closeErrorBtn.addEventListener('click', () => errorModal.classList.add('hidden'));
    </script>
    <style>
        /* Custom scrollbar for filter list */
        .custom-scrollbar::-webkit-scrollbar {
            height: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
                 background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
                 background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                 background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
        }
        body{


                             background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);

        }

        #kk{

                              background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);

            
        }
        #kkk{

                                background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);

            
        }
    </style>
</body>
</html>
