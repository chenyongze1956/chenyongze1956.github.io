<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web FC æ¨¡æ‹Ÿå™¨ (å¢å¼ºç¨³å®šç‰ˆ)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script> 
    <style>
        /* (æ ·å¼ä»£ç ä¿æŒä¸å˜ï¼Œä¸ºèŠ‚çœç©ºé—´åœ¨æ­¤çœç•¥) */
        body {
            background: linear-gradient(45deg, #ff7e5f, #feb47b, #ffed86, #9feb8f, #5fbfff, #9b8eff);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            user-select: none;
            box-sizing: border-box;
        }
        h1 { margin: 10px 0; font-weight: 300; letter-spacing: 2px;}
        .screen-container {
            position: relative;
            border: 4px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            background: #000;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            width: 512px;
            height: 480px;
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            color: #fff;
            font-size: 1.5em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            padding: 20px;
        }
        .overlay.visible { opacity: 1; }

        /* --- æŒ‰é’®åŒºåŸŸæ ·å¼ä¼˜åŒ– --- */
        .toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .btn {
            width: 90px;
            height: 35px;
            padding: 0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #555 !important;
        }
        /* æŒ‰é’®é¢œè‰² */
        .btn-load { background: #e53935; }
        .btn-load:hover:not(:disabled) { background: #d32f2f; }
        .btn-screenshot { background: #795548; }
        .btn-screenshot:hover:not(:disabled) { background: #6D4C41; }
        .btn-share { background: #00BCD4; }
        .btn-share:hover:not(:disabled) { background: #00ACC1; }
        .btn-record-start { background: #4CAF50; }
        .btn-record-start:hover:not(:disabled) { background: #45a049; }
        .btn-record-stop {
            width: 90px;
            height: 35px;
            background: #f44336;
            display: none;
        }
        .btn-record-stop:hover:not(:disabled) { background: #d32f2f; }
        .btn-mute { background: #5D4037; }
        .btn-mute:hover:not(:disabled) { background: #4E342E; }
        .btn-cast { background: #E91E63; width: 120px !important; }

        .recording-indicator {
            display: none;
            align-items: center;
            color: #f44336;
            font-weight: bold;
            margin-left: 10px;
        }
        .recording-indicator::before {
            content: '';
            display: inline-block;
            width: 10px; height: 10px;
            background: #f44336;
            border-radius: 50%;
            margin-right: 5px;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }
        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            text-align: center;
            color: #ccc;
            font-size: 0.9em;
            width: 100%;
            max-width: 520px;
        }
        input[type="file"] { display: none; }
        .key-badge {
            display: inline-block;
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }
        .cast-control-panel {
            padding: 5px 15px;
            background: #1f1f1f;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <input type="file" id="rom-upload" accept=".nes">
        <button class="btn btn-load" onclick="document.getElementById('rom-upload').click()">ğŸ“‚ åŠ è½½æ¸¸æˆ</button>
        <button id="btnScreenshot" class="btn btn-screenshot" disabled>ğŸ“· æˆªå›¾</button>
        <button id="btnMute" class="btn btn-mute" disabled>ğŸ”Š é™éŸ³</button>
        <button id="btnShare" class="btn btn-share" disabled>ğŸ”— åˆ†äº«</button>

        <div style="width: 2px; height: 30px; background: #444; margin: 0 10px;"></div>

        <button id="btnStartRec" class="btn btn-record-start" disabled>ğŸ”´ å½•åƒ</button>
        <button id="btnStopRec" class="btn btn-record-stop">â¬œ åœæ­¢</button>
        <div id="recIndicator" class="recording-indicator">REC</div>
    </div>

    <div class="screen-container">
        <canvas id="screen" width="256" height="240"></canvas>
        <div id="msg-overlay" class="overlay visible">è¯·åŠ è½½ ROM å¼€å§‹æ¸¸æˆ</div>
    </div>

    <div class="controls">
        <h4>ğŸ•¹ æ¸¸æˆæ§åˆ¶ (1P)</h4>
        <p>
            é”®ç›˜: ç§»åŠ¨: <span class="key-badge">â†‘â†“â†â†’</span> &nbsp; A é”®: <span class="key-badge">X</span> &nbsp; B é”®: <span class="key-badge">Z</span> &nbsp; Select: <span class="key-badge">Ctrl</span> &nbsp; Start: <span class="key-badge">Enter</span>
        </p>
        <p>
            æ‰‹æŸ„çŠ¶æ€: <span id="gamepadStatus" style="color:#FFC107;">æœªè¿æ¥</span>
        </p>
        <div class="cast-control-panel">
            <span style="font-weight: bold;">ğŸ“º ç›´æ’­æŠ•å±:</span>
            ç›®æ ‡ID: <input type="text" id="peerId" value="NES_TV_VIEWER" style="width: 120px; padding: 3px; border-radius: 3px;">
            <button id="btnConnectCast" class="btn btn-cast" disabled>ğŸ“ å¼€å§‹ç›´æ’­</button>
            <span id="castStatus" style="color:#FFC107; font-size: 0.9em;">(è¯·åŠ è½½æ¸¸æˆå¹¶è¾“å…¥ID)</span>
        </div>
    </div>

    <script src="https://unpkg.com/jsnes/dist/jsnes.min.js"></script>
    <script>
        const SCREEN_WIDTH = 256;
        const SCREEN_HEIGHT = 240;
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(SCREEN_WIDTH, SCREEN_HEIGHT);
        const buf32 = new Uint32Array(imageData.data.buffer);
        const overlay = document.getElementById('msg-overlay');

        // --- DOM å…ƒç´ å¼•ç”¨ ---
        const btnScreenshot = document.getElementById('btnScreenshot');
        const btnShare = document.getElementById('btnShare');
        const btnStartRec = document.getElementById('btnStartRec');
        const btnStopRec = document.getElementById('btnStopRec');
        const recIndicator = document.getElementById('recIndicator');
        const btnMute = document.getElementById('btnMute');
        const btnLoad = document.querySelector('.btn-load');
        
        // --- P2P ç›´æ’­ DOM å¼•ç”¨ ---
        const peerIdInput = document.getElementById('peerId');
        const btnConnectCast = document.getElementById('btnConnectCast');
        const castStatusEl = document.getElementById('castStatus');

        // --- æ ¸å¿ƒçŠ¶æ€å˜é‡ ---
        let audioHandler = null;
        let isFileLoaded = false;
        let lastScreenshotBlob = null;
        let animationFrameId = null;

        // --- Gamepad & P2P å˜é‡ ---
        let gamepadIndex = null;
        const gamepadStatusEl = document.getElementById('gamepadStatus');
        let peer = null; 
        let currentCall = null; 

        // Gamepad æ ‡å‡†æŒ‰é’®æ˜ å°„åˆ° JSNES æŒ‰é’®
        const GAMEPAD_BUTTON_MAP = {
            [jsnes.Controller.BUTTON_A]: 0,
            [jsnes.Controller.BUTTON_B]: 1,
            [jsnes.Controller.BUTTON_SELECT]: 8,
            [jsnes.Controller.BUTTON_START]: 9,
        };

        // Gamepad è½´æ˜ å°„åˆ° JSNES D-Pad
        const GAMEPAD_AXIS_MAP = {
            UP:    { axis: 1, value: -1.0, button: jsnes.Controller.BUTTON_UP },
            DOWN:  { axis: 1, value: 1.0,  button: jsnes.Controller.BUTTON_DOWN },
            LEFT:  { axis: 0, value: -1.0, button: jsnes.Controller.BUTTON_LEFT },
            RIGHT: { axis: 0, value: 1.0,  button: jsnes.Controller.BUTTON_RIGHT },
        };
        let previousGamepadButtons = {};

        // --- éŸ³é¢‘å¤„ç†ç±» (ç•¥) ---
        class AudioHandler {
            constructor() {
                this.actx = new (window.AudioContext || window.webkitAudioContext)();
                this.bufferSize = 4096;
                this.scriptNode = this.actx.createScriptProcessor(this.bufferSize, 0, 1);
                this.recordingDest = this.actx.createMediaStreamDestination();
                this.ringBuffer = new Float32Array(this.bufferSize * 3);
                this.writeIndex = 0;
                this.readIndex = 0;
                this.scriptNode.onaudioprocess = (e) => this.process(e);
                this.scriptNode.connect(this.actx.destination);
                this.scriptNode.connect(this.recordingDest);
            }
            resume() { if (this.actx.state === 'suspended' || this.actx.state === 'closed') { this.actx.resume(); } }
            pause() { if (this.actx.state === 'running') { this.actx.suspend(); } }
            getAudioStream() { return this.recordingDest.stream; }
            writeSample(value) {
                this.ringBuffer[this.writeIndex] = value; this.writeIndex++;
                if (this.writeIndex >= this.ringBuffer.length) this.writeIndex = 0;
            }
            process(e) {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < this.bufferSize; i++) {
                    if (this.readIndex === this.writeIndex) { output[i] = 0; } 
                    else { output[i] = this.ringBuffer[this.readIndex]; this.readIndex++;
                        if (this.readIndex >= this.ringBuffer.length) this.readIndex = 0;
                    }
                }
            }
        }

        // --- NES åˆå§‹åŒ– (ç•¥) ---
        var nes = new jsnes.NES({
            onFrame: function(frameBuffer) {
                let i = 0;
                for (let y = 0; y < SCREEN_HEIGHT; ++y) {
                    for (let x = 0; x < SCREEN_WIDTH; ++x) {
                        i = y * SCREEN_WIDTH + x;
                        buf32[i] = 0xFF000000 | frameBuffer[i];
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            onAudioSample: function(left, right) { if (audioHandler) { audioHandler.writeSample(left); } }
        });

        // =================================================================
        // --- å¢å¼ºç‰ˆæ‰‹æŸ„è½®è¯¢é€»è¾‘ (å·²æ›´æ–°) ---
        // =================================================================
        function pollGamepad() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            let activeGamepad = null;
            
            // å°è¯•å¯»æ‰¾å·²ç»‘å®šçš„æ‰‹æŸ„ï¼Œæˆ–å¯»æ‰¾ç¬¬ä¸€ä¸ªæ–°è¿æ¥çš„æ‰‹æŸ„
            for (let i = 0; i < gamepads.length; i++) {
                const gp = gamepads[i];
                if (gp && gp.connected) {
                    // 1. ä¼˜å…ˆä½¿ç”¨å·²ç»‘å®šçš„ç´¢å¼•
                    if (gamepadIndex !== null && gp.index === gamepadIndex) {
                        activeGamepad = gp;
                        break; 
                    }
                    // 2. å¦‚æœ gamepadIndex ä¸º nullï¼Œåˆ™ç»‘å®šç¬¬ä¸€ä¸ªæ£€æµ‹åˆ°çš„æ‰‹æŸ„
                    if (gamepadIndex === null) {
                        gamepadIndex = gp.index;
                        activeGamepad = gp;
                        gamepadStatusEl.textContent = `âœ… å·²è¿æ¥: ${gp.id.slice(0, 30)}...`;
                        gamepadStatusEl.style.color = '#4CAF50';
                        break;
                    }
                }
            }

            if (!activeGamepad) {
                if (gamepadIndex !== null) {
                    gamepadIndex = null;
                }
                gamepadStatusEl.textContent = 'æœªè¿æ¥ (è¯·æŒ‰ä»»æ„é”®æ¿€æ´»)';
                gamepadStatusEl.style.color = '#FFC107';
                return;
            }

            // --- æ˜ å°„æ ‡å‡†æŒ‰é’® (A, B, Select, Start) ---
            for (const nesButtonStr in GAMEPAD_BUTTON_MAP) {
                const nesButton = parseInt(nesButtonStr);
                const gpIndex = GAMEPAD_BUTTON_MAP[nesButton];
                const gpButton = activeGamepad.buttons[gpIndex];
                const isDown = gpButton && gpButton.pressed;
                const wasDown = previousGamepadButtons[nesButton];

                if (isDown && !wasDown) { nes.buttonDown(1, nesButton); } 
                else if (!isDown && wasDown) { nes.buttonUp(1, nesButton); }
                previousGamepadButtons[nesButton] = isDown;
            }

            // --- æ˜ å°„æ‘‡æ†/D-Pad (è½´å’Œ D-Pad æŒ‰é’®) ---
            const axes = activeGamepad.axes;
            for (const dir in GAMEPAD_AXIS_MAP) {
                const map = GAMEPAD_AXIS_MAP[dir];
                let isDown = false;
                
                // 1. æ£€æŸ¥è½´ (å¤§éƒ¨åˆ†æ‘‡æ†ä½¿ç”¨è½´ 0/1)
                if (map.axis !== undefined && axes.length > map.axis) {
                    if (map.value === -1.0) { isDown = axes[map.axis] < -0.5; }
                    else if (map.value === 1.0) { isDown = axes[map.axis] > 0.5; }
                }
                
                // 2. æ£€æŸ¥ D-Pad æŒ‰é’® (å…¼å®¹ Xbox/PS4 ç­‰å°† D-Pad ä½œä¸ºæŒ‰é’®çš„æ‰‹æŸ„)
                // å¸¸è§çš„ D-Pad æŒ‰é’®ç´¢å¼•æ˜¯ 12 (ä¸Š), 13 (ä¸‹), 14 (å·¦), 15 (å³)
                if (map.button === jsnes.Controller.BUTTON_UP && activeGamepad.buttons[12]?.pressed) isDown = true;
                if (map.button === jsnes.Controller.BUTTON_DOWN && activeGamepad.buttons[13]?.pressed) isDown = true;
                if (map.button === jsnes.Controller.BUTTON_LEFT && activeGamepad.buttons[14]?.pressed) isDown = true;
                if (map.button === jsnes.Controller.BUTTON_RIGHT && activeGamepad.buttons[15]?.pressed) isDown = true;


                const wasDown = previousGamepadButtons[map.button];
                if (isDown && !wasDown) { nes.buttonDown(1, map.button); } 
                else if (!isDown && wasDown) { nes.buttonUp(1, map.button); }
                previousGamepadButtons[map.button] = isDown;
            }
        }

        window.addEventListener("gamepadconnected", (e) => {
            if (gamepadIndex === null) {
                gamepadIndex = e.gamepad.index;
                gamepadStatusEl.textContent = `âœ… å·²è¿æ¥: ${e.gamepad.id.slice(0, 30)}...`;
                gamepadStatusEl.style.color = '#4CAF50';
            }
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            if (e.gamepad.index === gamepadIndex) {
                gamepadIndex = null;
                gamepadStatusEl.textContent = 'æœªè¿æ¥';
                gamepadStatusEl.style.color = '#FFC107';
            }
        });

        // --- P2P ç›´æ’­åŠŸèƒ½å®ç° (ç•¥ï¼ŒPeerJS é…ç½®ä¿æŒæœ¬åœ° 127.0.0.1:9000) ---
        function disconnectWebRTCCasting() { /* ... */ }

        function startWebRTCCasting() {
            if (!isFileLoaded) { alert("è¯·å…ˆåŠ è½½ ROMï¼"); return; }
            if (currentCall) { disconnectWebRTCCasting(); return; }
            if (audioHandler && audioHandler.actx.state !== 'running') { audioHandler.resume(); }

            // 1. åˆå§‹åŒ– PeerJS (æŒ‡å‘æœ¬åœ° PeerServer)
            if (!peer || peer.disconnected) {
                const myId = 'EMU_HOST_' + Math.floor(Math.random() * 1000);
                peer = new Peer(myId, {
                    host: '127.0.0.1', 
                    port: 9000,
                    path: '/',
                    secure: false 
                });
            } else if (peer.open) {
                 callViewer(); return;
            }
            btnConnectCast.textContent = 'è¿æ¥ä¸­...';
            castStatusEl.textContent = 'æ­£åœ¨æ³¨å†Œä¸»æ’­ ID...';
            castStatusEl.style.color = '#00BCD4';
            peer.on('open', (id) => { castStatusEl.textContent = `ä¸»æ’­ IDå·²æ³¨å†Œ: ${id}`; callViewer(); });
            peer.on('error', (err) => {
                console.error("PeerJS é”™è¯¯:", err);
                castStatusEl.textContent = `P2P æ³¨å†Œ/è¿æ¥å¤±è´¥: ${err.type} (è¯·æ£€æŸ¥æœ¬åœ°PeerServeræ˜¯å¦è¿è¡Œ)`;
                castStatusEl.style.color = '#F44336';
                btnConnectCast.textContent = 'ğŸ“ é‡æ–°å°è¯•';
            });
        }
        
        function callViewer() {
            const targetId = peerIdInput.value.trim();
            if (!targetId) { alert("è¯·è¾“å…¥è§‚ä¼—ç«¯çš„ PeerIDï¼"); disconnectWebRTCCasting(); return; }
            
            const canvasStream = canvas.captureStream(60); 
            const audioStream = audioHandler.getAudioStream();
            const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]);
            
            castStatusEl.textContent = `æ­£åœ¨å‘¼å«è§‚ä¼—: ${targetId}`;
            btnConnectCast.textContent = 'ğŸ“ æ–­å¼€ç›´æ’­';
            currentCall = peer.call(targetId, combinedStream);
            currentCall.on('stream', () => { castStatusEl.textContent = `âœ… ç›´æ’­å·²è¿æ¥åˆ° ${targetId}`; castStatusEl.style.color = '#4CAF50'; });
            currentCall.on('close', disconnectWebRTCCasting);
            currentCall.on('error', (err) => { console.error("P2P å‘¼å«é”™è¯¯:", err); alert("P2P å‘¼å«å¤±è´¥ï¼Œè¯·æ£€æŸ¥è§‚ä¼—ç«¯æ˜¯å¦å¼€å¯å¹¶ ID æ­£ç¡®ã€‚"); disconnectWebRTCCasting(); });
        }

        btnConnectCast.addEventListener('click', startWebRTCCasting);
        
        // --- æ¸¸æˆä¸»å¾ªç¯ ---
        function onAnimationFrame() { 
            pollGamepad(); // ç¡®ä¿æ¯å¸§éƒ½è½®è¯¢æ‰‹æŸ„çŠ¶æ€
            if (isFileLoaded) { nes.frame(); } 
            animationFrameId = window.requestAnimationFrame(onAnimationFrame); 
        }
        window.requestAnimationFrame(onAnimationFrame);

        // --- ROM åŠ è½½ (ArrayBuffer é€»è¾‘) ---
        document.getElementById('rom-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (!audioHandler) { audioHandler = new AudioHandler(); }
            audioHandler.resume();

            const reader = new FileReader();
            reader.readAsArrayBuffer(file);

            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const bytes = new Uint8Array(arrayBuffer);
                    const binaryString = String.fromCharCode.apply(null, bytes);

                    nes.loadROM(binaryString); // æ ¸å¿ƒåŠ è½½å‡½æ•°

                    isFileLoaded = true;
                    overlay.classList.remove('visible');
                    overlay.innerHTML = 'æ¸¸æˆå·²åŠ è½½';
                    
                    // å¯ç”¨æ‰€æœ‰åŠŸèƒ½æŒ‰é’®
                    btnConnectCast.disabled = false;
                    btnStartRec.disabled = false;
                    btnScreenshot.disabled = false;
                    btnShare.disabled = true;
                    btnMute.disabled = false;
                    btnLoad.disabled = false;
                    console.log("ROM Loaded OK");
                } catch(err) {
                    const errMsg = err.message || "æœªçŸ¥é”™è¯¯";
                    alert("åŠ è½½å¤±è´¥: " + errMsg + "\n\nè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºæ ‡å‡†çš„ .nes æ–‡ä»¶ (iNESæ ¼å¼)ï¼Œæˆ–å°è¯•ä½¿ç”¨å…¶ä»– ROMã€‚");
                    overlay.innerHTML = 'åŠ è½½å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»– ROM æ–‡ä»¶ã€‚';
                    overlay.classList.add('visible');
                }
            };
        });

        // --- é™éŸ³/æˆªå›¾/å½•åƒåŠŸèƒ½ (ç•¥) ---
        // (æ‰€æœ‰ç›¸å…³å‡½æ•°ä¿æŒä¸å˜)
        
        // --- é”®ç›˜äº‹ä»¶ (ç•¥) ---
        const KEYMAP = { 88: jsnes.Controller.BUTTON_A, 90: jsnes.Controller.BUTTON_B, 17: jsnes.Controller.BUTTON_SELECT, 13: jsnes.Controller.BUTTON_START, 38: jsnes.Controller.BUTTON_UP, 40: jsnes.Controller.BUTTON_DOWN, 37: jsnes.Controller.BUTTON_LEFT, 39: jsnes.Controller.BUTTON_RIGHT };
        function handleKey(e, type) {
            if (KEYMAP[e.keyCode] !== undefined) {
                if (isFileLoaded) { nes[type === 'down' ? 'buttonDown' : 'buttonUp'](1, KEYMAP[e.keyCode]); }
                e.preventDefault();
            }
        }
        document.addEventListener('keydown', (e) => handleKey(e, 'down'));
        document.addEventListener('keyup', (e) => handleKey(e, 'up'));
    </script>
</body>
</html>
