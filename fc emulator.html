
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web FC æ¨¡æ‹Ÿå™¨ (å«å½•åƒ/å­˜æ¡£)</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ä¿æŒä¸å˜ --- */
        body {
     background: linear-gradient(45deg,#ff7e5f,#feb47b,#ffed86,#9feb8f,#5fbfff,#9b8eff);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            user-select: none;
            box-sizing: border-box;
        }
        h1 { margin: 10px 0; font-weight: 300; letter-spacing: 2px;}
        .screen-container {
            position: relative;
            border: 4px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            background: #000;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            width: 512px; 
            height: 480px;
        }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            color: #fff;
            font-size: 1.2em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .overlay.visible { opacity: 1; }
        
        /* --- æŒ‰é’®åŒºåŸŸæ ·å¼ä¼˜åŒ– --- */
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap; /* ä¿è¯åœ¨å°å±å¹•ä¸Šä¸æº¢å‡º */
            justify-content: center;
        }

        .btn {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #555 !important;
        }
        .btn-load { background: #e53935; }
        .btn-load:hover:not(:disabled) { background: #d32f2f; }
        
        /* å­˜æ¡£æŒ‰é’®é¢œè‰² */
        .btn-save { background: #1976D2; } 
        .btn-save:hover:not(:disabled) { background: #1565C0; }

        /* è¯»æ¡£æŒ‰é’®é¢œè‰² */
        .btn-load-state { background: #0097A7; }
        .btn-load-state:hover:not(:disabled) { background: #00838F; }

        .btn-record-start { background: #4CAF50; }
        .btn-record-start:hover:not(:disabled) { background: #45a049; }

        .btn-record-stop { background: #f44336; display: none; }
        .btn-record-stop:hover:not(:disabled) { background: #d32f2f; }

        .recording-indicator {
            display: none;
            align-items: center;
            color: #f44336;
            font-weight: bold;
            margin-left: 10px;
        }
        .recording-indicator::before {
            content: '';
            display: inline-block;
            width: 10px; height: 10px;
            background: #f44336;
            border-radius: 50%;
            margin-right: 5px;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0; } }

        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            text-align: center;
            color: #ccc;
            font-size: 0.9em;
        }
        input[type="file"] { display: none; }
        .key-badge {
            display: inline-block;
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>
<body>

  
    
    <div class="toolbar">
        <input type="file" id="rom-upload" accept=".nes">
        <button class="btn btn-load" onclick="document.getElementById('rom-upload').click()">ğŸ“‚ åŠ è½½æ¸¸æˆ</button>
        
        <button id="btnSaveState" class="btn btn-save" disabled>ğŸ’¾ ä¿å­˜è¿›åº¦</button>
        <button id="btnLoadState" class="btn btn-load-state" disabled>ğŸ“¥ è½½å…¥è¿›åº¦</button>

        <div style="width: 2px; height: 30px; background: #444; margin: 0 10px;"></div>
        
        <button id="btnStartRec" class="btn btn-record-start" disabled>ğŸ”´ å¼€å§‹å½•åƒ</button>
        <button id="btnStopRec" class="btn btn-record-stop">â¬œ åœæ­¢å½•åƒ</button>
        <div id="recIndicator" class="recording-indicator">REC</div>
    </div>

    <div class="screen-container">
        <canvas id="screen" width="256" height="240"></canvas>
        <div id="msg-overlay" class="overlay visible">è¯·åŠ è½½ ROM å¼€å§‹æ¸¸æˆ</div>
    </div>

  

    <script src="https://unpkg.com/jsnes/dist/jsnes.min.js"></script>

    <script>
        const SCREEN_WIDTH = 256;
        const SCREEN_HEIGHT = 240;
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(SCREEN_WIDTH, SCREEN_HEIGHT);
        const buf32 = new Uint32Array(imageData.data.buffer);
        const overlay = document.getElementById('msg-overlay');

        // --- å­˜æ¡£åŠŸèƒ½æ–°å¢çš„ DOM å…ƒç´  ---
        const btnSaveState = document.getElementById('btnSaveState');
        const btnLoadState = document.getElementById('btnLoadState');
        
        // --- å½•åƒåŠŸèƒ½ DOM å…ƒç´  ---
        const btnStartRec = document.getElementById('btnStartRec');
        const btnStopRec = document.getElementById('btnStopRec');
        const recIndicator = document.getElementById('recIndicator');

        // --- å­˜æ¡£åŠŸèƒ½å¸¸é‡ ---
        const SAVE_STATE_KEY = 'NES_SAVE_STATE';
        let currentROMName = ''; // ç”¨äºåŒºåˆ†ä¸åŒæ¸¸æˆçš„å­˜æ¡£

        // --- éŸ³é¢‘å¤„ç†ç±» (æ”¯æŒå½•åƒæµ) ---
        class AudioHandler {
            constructor() {
                this.actx = new (window.AudioContext || window.webkitAudioContext)();
                this.bufferSize = 4096;
                this.scriptNode = this.actx.createScriptProcessor(this.bufferSize, 0, 1);
                this.recordingDest = this.actx.createMediaStreamDestination();
                this.ringBuffer = new Float32Array(this.bufferSize * 3); 
                this.writeIndex = 0;
                this.readIndex = 0;
                
                this.scriptNode.onaudioprocess = (e) => this.process(e);
                this.scriptNode.connect(this.actx.destination);
                this.scriptNode.connect(this.recordingDest);
            }

            resume() {
                if (this.actx.state === 'suspended') {
                    this.actx.resume();
                }
            }
            getAudioStream() { return this.recordingDest.stream; }
            writeSample(value) {
                this.ringBuffer[this.writeIndex] = value;
                this.writeIndex++;
                if (this.writeIndex >= this.ringBuffer.length) this.writeIndex = 0;
            }
            process(e) {
                const output = e.outputBuffer.getChannelData(0);
                for (let i = 0; i < this.bufferSize; i++) {
                    if (this.readIndex === this.writeIndex) {
                        output[i] = 0; 
                    } else {
                        output[i] = this.ringBuffer[this.readIndex];
                        this.readIndex++;
                        if (this.readIndex >= this.ringBuffer.length) this.readIndex = 0;
                    }
                }
            }
        }

        let audioHandler = null;
        let isFileLoaded = false;

        // --- NES åˆå§‹åŒ– ---
        var nes = new jsnes.NES({
            onFrame: function(frameBuffer) {
                let i = 0;
                for (let y = 0; y < SCREEN_HEIGHT; ++y) {
                    for (let x = 0; x < SCREEN_WIDTH; ++x) {
                        i = y * SCREEN_WIDTH + x;
                        buf32[i] = 0xFF000000 | frameBuffer[i]; 
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            onAudioSample: function(left, right) {
                if (audioHandler) {
                    audioHandler.writeSample(left); 
                }
            }
        });

        // --- æ¸¸æˆä¸»å¾ªç¯ ---
        function onAnimationFrame() {
            window.requestAnimationFrame(onAnimationFrame);
            if (isFileLoaded) {
                nes.frame();
            }
        }
        window.requestAnimationFrame(onAnimationFrame);

        // --- ROM åŠ è½½ ---
        document.getElementById('rom-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // æå– ROM åç§°ç”¨äºå­˜æ¡£KEY
            currentROMName = file.name.replace(/\.nes$/i, ''); 

            if (!audioHandler) {
                audioHandler = new AudioHandler();
            }
            audioHandler.resume();

            const reader = new FileReader();
            reader.readAsBinaryString(file);
            
            reader.onload = function(e) {
                try {
                    nes.loadROM(e.target.result);
                    isFileLoaded = true;
                    overlay.classList.remove('visible');
                    // æ¸¸æˆåŠ è½½æˆåŠŸåï¼Œå¯ç”¨æ‰€æœ‰åŠŸèƒ½æŒ‰é’®
                    btnStartRec.disabled = false;
                    btnSaveState.disabled = false;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰è¯¥æ¸¸æˆçš„å­˜æ¡£
                    const stateKey = SAVE_STATE_KEY + '_' + currentROMName;
                    btnLoadState.disabled = !localStorage.getItem(stateKey);
                    
                    console.log(`ROM Loaded: ${currentROMName}`);
                } catch(err) {
                    alert("åŠ è½½å¤±è´¥: " + err);
                }
            };
        });

        // ============================
        // --- å­˜æ¡£/è¯»æ¡£åŠŸèƒ½å®ç° (æ–°å¢) ---
        // ============================

        function saveGameState() {
            if (!isFileLoaded || !currentROMName) return;
            
            try {
                // 1. è·å– jsnes å­˜æ¡£æ•°æ® (JSON Object)
                const state = nes.saveState();
                // 2. è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶å­˜å…¥ localStorageï¼Œä½¿ç”¨ ROM åç§°ä½œä¸º KEY
                const stateKey = SAVE_STATE_KEY + '_' + currentROMName;
                localStorage.setItem(stateKey, JSON.stringify(state));
                
                btnLoadState.disabled = false; // å­˜æ¡£åï¼Œè½½å…¥æŒ‰é’®å¯ç”¨
                alert(`å­˜æ¡£æˆåŠŸï¼æ¸¸æˆè¿›åº¦å·²ä¿å­˜åˆ°æµè§ˆå™¨ã€‚`);
            } catch (e) {
                console.error("å­˜æ¡£å¤±è´¥:", e);
                alert("å­˜æ¡£å¤±è´¥ï¼");
            }
        }

        function loadGameState() {
            if (!isFileLoaded || !currentROMName) return;
            
            const stateKey = SAVE_STATE_KEY + '_' + currentROMName;
            const savedStateString = localStorage.getItem(stateKey);
            
            if (!savedStateString) {
                alert("æ²¡æœ‰æ‰¾åˆ°å½“å‰æ¸¸æˆçš„å­˜æ¡£ï¼");
                return;
            }

            try {
                // 1. è§£æå­˜æ¡£å­—ç¬¦ä¸²
                const state = JSON.parse(savedStateString);
                // 2. è½½å…¥å­˜æ¡£
                nes.loadState(state);
                alert(`è½½å…¥å­˜æ¡£æˆåŠŸï¼`);
            } catch (e) {
                console.error("è½½å…¥å­˜æ¡£å¤±è´¥:", e);
                alert("è½½å…¥å­˜æ¡£å¤±è´¥ï¼Œå¯èƒ½å­˜æ¡£æ–‡ä»¶æŸåã€‚");
            }
        }

        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        btnSaveState.addEventListener('click', saveGameState);
        btnLoadState.addEventListener('click', loadGameState);


        // ============================
        // --- å½•åƒåŠŸèƒ½å®ç° (ä¿æŒä¸å˜) ---
        // ============================
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        btnStartRec.addEventListener('click', startRecording);
        btnStopRec.addEventListener('click', stopRecording);

        function getMimeTypeOptions() {
            const mp4Mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
            const webmMime = 'video/webm; codecs=vp9,opus';
            if (MediaRecorder.isTypeSupported(mp4Mime)) { return { mimeType: mp4Mime }; } 
            if (MediaRecorder.isTypeSupported(webmMime)) { return { mimeType: webmMime }; } 
            return {};
        }

        function startRecording() {
            if (!isFileLoaded || !audioHandler || isRecording) return;

            const canvasStream = canvas.captureStream(60);
            const audioStream = audioHandler.getAudioStream();
            const combinedStream = new MediaStream([
                ...canvasStream.getVideoTracks(),
                ...audioStream.getAudioTracks()
            ]);

            const options = getMimeTypeOptions();
            if (!options.mimeType) { alert("å½•åƒåŠŸèƒ½ä¸å¯ç”¨ï¼Œæµè§ˆå™¨ä¸æ”¯æŒæ‰€éœ€çš„è§†é¢‘ç¼–ç ã€‚"); return; }

            try {
                mediaRecorder = new MediaRecorder(combinedStream, options);
            } catch (e) {
                console.error("åˆå§‹åŒ– MediaRecorder å¤±è´¥:", e);
                alert("åˆå§‹åŒ–å½•åƒå¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯¥æ ¼å¼ã€‚");
                return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = downloadRecording;

            mediaRecorder.start();
            isRecording = true;
            updateRecordUI(true);
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                updateRecordUI(false);
            }
        }

        function downloadRecording() {
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            
            const actualMimeType = mediaRecorder.mimeType.toLowerCase();
            const fileExt = actualMimeType.includes('mp4') ? 'mp4' : 'webm';
            
            const timestamp = new Date().toISOString().slice(0,19).replace(/[-T:]/g, '');
            a.download = `FC_Gameplay_${timestamp}.${fileExt}`;
            
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                alert(`å½•åƒå·²å®Œæˆå¹¶å¼€å§‹ä¸‹è½½ï¼æ ¼å¼: .${fileExt}`);
            }, 100);
        }

        function updateRecordUI(recording) {
            if (recording) {
                btnStartRec.style.display = 'none';
                btnStopRec.style.display = 'flex';
                recIndicator.style.display = 'flex';
                document.querySelector('.btn-load').disabled = true;
                btnSaveState.disabled = true; // å½•åƒæ—¶ç¦ç”¨å­˜æ¡£ï¼Œé˜²æ­¢æ•°æ®æ··ä¹±
                btnLoadState.disabled = true;
            } else {
                btnStartRec.style.display = 'flex';
                btnStopRec.style.display = 'none';
                recIndicator.style.display = 'none';
                document.querySelector('.btn-load').disabled = false;
                btnSaveState.disabled = false;
                // æ¢å¤è½½å…¥çŠ¶æ€æŒ‰é’®çš„å¯ç”¨æ€§æ£€æŸ¥
                const stateKey = SAVE_STATE_KEY + '_' + currentROMName;
                btnLoadState.disabled = !localStorage.getItem(stateKey);
            }
        }

        // --- é”®ç›˜äº‹ä»¶ ---
        const KEYMAP = {
            88: jsnes.Controller.BUTTON_A,      
            90: jsnes.Controller.BUTTON_B,      
            17: jsnes.Controller.BUTTON_SELECT, 
            13: jsnes.Controller.BUTTON_START,  
            38: jsnes.Controller.BUTTON_UP,
            40: jsnes.Controller.BUTTON_DOWN,
            37: jsnes.Controller.BUTTON_LEFT,
            39: jsnes.Controller.BUTTON_RIGHT
        };

        function handleKey(e, type) {
            if (KEYMAP[e.keyCode] !== undefined) {
                nes[type === 'down' ? 'buttonDown' : 'buttonUp'](1, KEYMAP[e.keyCode]);
                e.preventDefault();
            }
        }
        document.addEventListener('keydown', (e) => handleKey(e, 'down'));
        document.addEventListener('keyup', (e) => handleKey(e, 'up'));

    </script>
</body>
</html>
